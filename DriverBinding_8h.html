<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XenevaOS: XenevaOS/Boot/include/Protocol/DriverBinding.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">XenevaOS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_6f7cbf0a11b44b0a43b1ec16e930d793.html">XenevaOS</a></li><li class="navelem"><a class="el" href="dir_e155a64606be01e9718a8b1197c63fff.html">Boot</a></li><li class="navelem"><a class="el" href="dir_08690fdcb6b3138c931f33749be09044.html">include</a></li><li class="navelem"><a class="el" href="dir_b641ebb3d870e3bbb06aca4db697d2ea.html">Protocol</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">DriverBinding.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="DriverBinding_8h__dep__incl.png" border="0" usemap="#aXenevaOS_2Boot_2include_2Protocol_2DriverBinding_8hdep" alt=""/></div>
<map name="aXenevaOS_2Boot_2include_2Protocol_2DriverBinding_8hdep" id="aXenevaOS_2Boot_2include_2Protocol_2DriverBinding_8hdep">
<area shape="rect" title=" " alt="" coords="594,5,778,45"/>
<area shape="rect" href="UefiLib_8h.html" title=" " alt="" coords="599,93,773,133"/>
<area shape="poly" title=" " alt="" coords="689,59,689,93,683,93,683,59"/>
<area shape="rect" href="Boot_2video_8h.html" title=" " alt="" coords="315,181,489,207"/>
<area shape="poly" title=" " alt="" coords="606,140,444,184,443,179,604,134"/>
<area shape="rect" href="Boot_2xnldr_8cpp.html" title=" " alt="" coords="435,255,622,280"/>
<area shape="poly" title=" " alt="" coords="658,145,543,256,539,252,655,141"/>
<area shape="rect" href="BootAA64_2video_8h.html" title=" " alt="" coords="741,181,951,207"/>
<area shape="poly" title=" " alt="" coords="738,137,824,179,821,184,735,142"/>
<area shape="rect" href="BootAA64_2xnldr_8cpp.html" title=" " alt="" coords="1143,255,1363,280"/>
<area shape="poly" title=" " alt="" coords="782,134,963,179,1216,252,1215,257,961,184,780,139"/>
<area shape="rect" href="Boot_2video_8cpp.html" title=" " alt="" coords="5,255,196,280"/>
<area shape="poly" title=" " alt="" coords="341,212,150,257,149,252,340,207"/>
<area shape="poly" title=" " alt="" coords="436,211,509,252,507,257,433,216"/>
<area shape="rect" href="Boot_2xnout_8cpp.html" title=" " alt="" coords="220,255,411,280"/>
<area shape="poly" title=" " alt="" coords="379,217,331,257,328,252,376,213"/>
<area shape="rect" href="BootAA64_2video_8cpp.html" title=" " alt="" coords="646,255,870,280"/>
<area shape="poly" title=" " alt="" coords="823,217,774,257,771,252,820,213"/>
<area shape="poly" title=" " alt="" coords="925,206,1188,252,1187,257,924,212"/>
<area shape="rect" href="BootAA64_2xnout_8cpp.html" title=" " alt="" coords="893,255,1119,280"/>
<area shape="poly" title=" " alt="" coords="885,210,981,252,979,257,883,215"/>
</map>
</div>
</div>
<p><a href="DriverBinding_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__EFI__DRIVER__BINDING__PROTOCOL.html">_EFI_DRIVER_BINDING_PROTOCOL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a7772d8413bb151a59688a6d679198ac4" id="r_a7772d8413bb151a59688a6d679198ac4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DriverBinding_8h.html#a7772d8413bb151a59688a6d679198ac4">EFI_DRIVER_BINDING_PROTOCOL_GUID</a></td></tr>
<tr class="separator:a7772d8413bb151a59688a6d679198ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae405748766385623110e2553c5eada18" id="r_ae405748766385623110e2553c5eada18"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__EFI__DRIVER__BINDING__PROTOCOL.html">_EFI_DRIVER_BINDING_PROTOCOL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DriverBinding_8h.html#ae405748766385623110e2553c5eada18">EFI_DRIVER_BINDING_PROTOCOL</a></td></tr>
<tr class="separator:ae405748766385623110e2553c5eada18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2393a08f91cbac2d51881b4b6634749" id="r_aa2393a08f91cbac2d51881b4b6634749"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DriverBinding_8h.html#aa2393a08f91cbac2d51881b4b6634749">EFI_DRIVER_BINDING_SUPPORTED</a>) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="DriverBinding_8h.html#ae405748766385623110e2553c5eada18">EFI_DRIVER_BINDING_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="UefiBaseType_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ControllerHandle, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="structEFI__DEVICE__PATH__PROTOCOL.html">EFI_DEVICE_PATH_PROTOCOL</a> *RemainingDevicePath <a class="el" href="Base_8h.html#afdff552467cc2d2d5815831e9656cffc">OPTIONAL</a>)</td></tr>
<tr class="separator:aa2393a08f91cbac2d51881b4b6634749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83adbd7d3d1aa2209c82e0f119eab188" id="r_a83adbd7d3d1aa2209c82e0f119eab188"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DriverBinding_8h.html#a83adbd7d3d1aa2209c82e0f119eab188">EFI_DRIVER_BINDING_START</a>) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="DriverBinding_8h.html#ae405748766385623110e2553c5eada18">EFI_DRIVER_BINDING_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="UefiBaseType_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ControllerHandle, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="structEFI__DEVICE__PATH__PROTOCOL.html">EFI_DEVICE_PATH_PROTOCOL</a> *RemainingDevicePath <a class="el" href="Base_8h.html#afdff552467cc2d2d5815831e9656cffc">OPTIONAL</a>)</td></tr>
<tr class="separator:a83adbd7d3d1aa2209c82e0f119eab188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b4faa6b90bd26fb89ca88c2f1749fb" id="r_a16b4faa6b90bd26fb89ca88c2f1749fb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DriverBinding_8h.html#a16b4faa6b90bd26fb89ca88c2f1749fb">EFI_DRIVER_BINDING_STOP</a>) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="DriverBinding_8h.html#ae405748766385623110e2553c5eada18">EFI_DRIVER_BINDING_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="UefiBaseType_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ControllerHandle, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> NumberOfChildren, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="UefiBaseType_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> *ChildHandleBuffer <a class="el" href="Base_8h.html#afdff552467cc2d2d5815831e9656cffc">OPTIONAL</a>)</td></tr>
<tr class="separator:a16b4faa6b90bd26fb89ca88c2f1749fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a28c565ce727b8661523ea1718e32ee8c" id="r_a28c565ce727b8661523ea1718e32ee8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="UefiBaseType_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="DriverBinding_8h.html#a28c565ce727b8661523ea1718e32ee8c">gEfiDriverBindingProtocolGuid</a></td></tr>
<tr class="separator:a28c565ce727b8661523ea1718e32ee8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>UEFI DriverBinding Protocol is defined in UEFI specification.</p>
<p>This protocol is produced by every driver that follows the UEFI Driver Model, and it is the central component that allows drivers and controllers to be managed.</p>
<p>Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<br  />
 This program and the accompanying materials are licensed and made available under the terms and conditions of the BSD License that accompanies this distribution. The full text of the license may be found at <a href="http://opensource.org/licenses/bsd-license.php">http://opensource.org/licenses/bsd-license.php</a>.</p>
<p>THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a7772d8413bb151a59688a6d679198ac4" name="a7772d8413bb151a59688a6d679198ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7772d8413bb151a59688a6d679198ac4">&#9670;&#160;</a></span>EFI_DRIVER_BINDING_PROTOCOL_GUID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_DRIVER_BINDING_PROTOCOL_GUID</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  { \</div>
<div class="line">    0x18a031ab, 0xb443, 0x4d1a, {0xa5, 0xc0, 0xc, 0x9, 0x26, 0x1e, 0x9f, 0x71 } \</div>
<div class="line">  }</div>
</div><!-- fragment --><p>The global ID for the ControllerHandle Driver Protocol. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ae405748766385623110e2553c5eada18" name="ae405748766385623110e2553c5eada18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae405748766385623110e2553c5eada18">&#9670;&#160;</a></span>EFI_DRIVER_BINDING_PROTOCOL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__EFI__DRIVER__BINDING__PROTOCOL.html">_EFI_DRIVER_BINDING_PROTOCOL</a> <a class="el" href="DriverBinding_8h.html#ae405748766385623110e2553c5eada18">EFI_DRIVER_BINDING_PROTOCOL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a83adbd7d3d1aa2209c82e0f119eab188" name="a83adbd7d3d1aa2209c82e0f119eab188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83adbd7d3d1aa2209c82e0f119eab188">&#9670;&#160;</a></span>EFI_DRIVER_BINDING_START</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_DRIVER_BINDING_START) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="DriverBinding_8h.html#ae405748766385623110e2553c5eada18">EFI_DRIVER_BINDING_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="UefiBaseType_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ControllerHandle, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="structEFI__DEVICE__PATH__PROTOCOL.html">EFI_DEVICE_PATH_PROTOCOL</a> *RemainingDevicePath <a class="el" href="Base_8h.html#afdff552467cc2d2d5815831e9656cffc">OPTIONAL</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts a device controller or a bus controller.</p>
<p>The Start() function is designed to be invoked from the EFI boot service ConnectController(). As a result, much of the error checking on the parameters to Start() has been moved into this common boot service. It is legal to call Start() from other locations, but the following calling restrictions must be followed, or the system behavior will not be deterministic.</p><ol type="1">
<li>ControllerHandle must be a valid EFI_HANDLE.</li>
<li>If RemainingDevicePath is not NULL, then it must be a pointer to a naturally aligned <a class="el" href="structEFI__DEVICE__PATH__PROTOCOL.html">EFI_DEVICE_PATH_PROTOCOL</a>.</li>
<li>Prior to calling Start(), the Supported() function for the driver specified by This must have been called with the same calling parameters, and Supported() must have returned EFI_SUCCESS.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_DRIVER_BINDING_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ControllerHandle</td><td>The handle of the controller to start. This handle must support a protocol interface that supplies an I/O abstraction to the driver. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RemainingDevicePath</td><td>A pointer to the remaining portion of a device path. This parameter is ignored by device drivers, and is optional for bus drivers. For a bus driver, if this parameter is NULL, then handles for all the children of Controller are created by this driver. If this parameter is not NULL and the first Device Path Node is not the End of Device Path Node, then only the handle for the child device specified by the first Device Path Node of RemainingDevicePath is created by this driver. If the first Device Path Node of RemainingDevicePath is the End of Device Path Node, no child handle is created by this driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The device was started. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device could not be started due to a device error.Currently not implemented. </td></tr>
    <tr><td class="paramname">EFI_OUT_OF_RESOURCES</td><td>The request could not be completed due to a lack of resources. </td></tr>
    <tr><td class="paramname">Others</td><td>The driver failded to start the device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16b4faa6b90bd26fb89ca88c2f1749fb" name="a16b4faa6b90bd26fb89ca88c2f1749fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b4faa6b90bd26fb89ca88c2f1749fb">&#9670;&#160;</a></span>EFI_DRIVER_BINDING_STOP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_DRIVER_BINDING_STOP) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="DriverBinding_8h.html#ae405748766385623110e2553c5eada18">EFI_DRIVER_BINDING_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="UefiBaseType_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ControllerHandle, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> NumberOfChildren, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="UefiBaseType_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> *ChildHandleBuffer <a class="el" href="Base_8h.html#afdff552467cc2d2d5815831e9656cffc">OPTIONAL</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops a device controller or a bus controller.</p>
<p>The Stop() function is designed to be invoked from the EFI boot service DisconnectController(). As a result, much of the error checking on the parameters to Stop() has been moved into this common boot service. It is legal to call Stop() from other locations, but the following calling restrictions must be followed, or the system behavior will not be deterministic.</p><ol type="1">
<li>ControllerHandle must be a valid EFI_HANDLE that was used on a previous call to this same driver's Start() function.</li>
<li>The first NumberOfChildren handles of ChildHandleBuffer must all be a valid EFI_HANDLE. In addition, all of these handles must have been created in this driver's Start() function, and the Start() function must have called OpenProtocol() on ControllerHandle with an Attribute of EFI_OPEN_PROTOCOL_BY_CHILD_CONTROLLER.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_DRIVER_BINDING_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ControllerHandle</td><td>A handle to the device being stopped. The handle must support a bus specific I/O protocol for the driver to use to stop the device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NumberOfChildren</td><td>The number of child device handles in ChildHandleBuffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ChildHandleBuffer</td><td>An array of child handles to be freed. May be NULL if NumberOfChildren is 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The device was stopped. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The device could not be stopped due to a device error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2393a08f91cbac2d51881b4b6634749" name="aa2393a08f91cbac2d51881b4b6634749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2393a08f91cbac2d51881b4b6634749">&#9670;&#160;</a></span>EFI_DRIVER_BINDING_SUPPORTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_DRIVER_BINDING_SUPPORTED) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="DriverBinding_8h.html#ae405748766385623110e2553c5eada18">EFI_DRIVER_BINDING_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="UefiBaseType_8h.html#af943d518ce8a229e7e51ce3fed0e3122">EFI_HANDLE</a> ControllerHandle, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="structEFI__DEVICE__PATH__PROTOCOL.html">EFI_DEVICE_PATH_PROTOCOL</a> *RemainingDevicePath <a class="el" href="Base_8h.html#afdff552467cc2d2d5815831e9656cffc">OPTIONAL</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests to see if this driver supports a given controller. If a child device is provided, it further tests to see if this driver supports creating a handle for the specified child device.</p>
<p>This function checks to see if the driver specified by This supports the device specified by ControllerHandle. Drivers will typically use the device path attached to ControllerHandle and/or the services from the bus I/O abstraction attached to ControllerHandle to determine if the driver supports ControllerHandle. This function may be called many times during platform initialization. In order to reduce boot times, the tests performed by this function must be very small, and take as little time as possible to execute. This function must not change the state of any hardware devices, and this function must be aware that the device specified by ControllerHandle may already be managed by the same driver or a different driver. This function must match its calls to <a class="el" href="MemoryAllocationLib_8h.html#a46b93a7b6c08cfdbfcabb98972b52dca">AllocatePages()</a> with <a class="el" href="MemoryAllocationLib_8h.html#a19764a0f29c0489f6e3666552276756f">FreePages()</a>, <a class="el" href="MemoryAllocationLib_8h.html#a1c677b257b7d0e9fee0ac869947c5606">AllocatePool()</a> with <a class="el" href="MemoryAllocationLib_8h.html#a8b1cbc21e0cebcfc6a992546ec9b4941">FreePool()</a>, and OpenProtocol() with CloseProtocol(). Because ControllerHandle may have been previously started by the same driver, if a protocol is already in the opened state, then it must not be closed with CloseProtocol(). This is required to guarantee the state of ControllerHandle is not modified by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_DRIVER_BINDING_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ControllerHandle</td><td>The handle of the controller to test. This handle must support a protocol interface that supplies an I/O abstraction to the driver. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RemainingDevicePath</td><td>A pointer to the remaining portion of a device path. This parameter is ignored by device drivers, and is optional for bus drivers. For bus drivers, if this parameter is not NULL, then the bus driver must determine if the bus controller specified by ControllerHandle and the child controller specified by RemainingDevicePath are both supported by this bus driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The device specified by ControllerHandle and RemainingDevicePath is supported by the driver specified by This. </td></tr>
    <tr><td class="paramname">EFI_ALREADY_STARTED</td><td>The device specified by ControllerHandle and RemainingDevicePath is already being managed by the driver specified by This. </td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The device specified by ControllerHandle and RemainingDevicePath is already being managed by a different driver or an application that requires exclusive access. Currently not implemented. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The device specified by ControllerHandle and RemainingDevicePath is not supported by the driver specified by This. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a28c565ce727b8661523ea1718e32ee8c" name="a28c565ce727b8661523ea1718e32ee8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c565ce727b8661523ea1718e32ee8c">&#9670;&#160;</a></span>gEfiDriverBindingProtocolGuid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="UefiBaseType_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> gEfiDriverBindingProtocolGuid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
