<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XenevaOS: XenevaOS/Boot/include/Protocol/MpService.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">XenevaOS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_6f7cbf0a11b44b0a43b1ec16e930d793.html">XenevaOS</a></li><li class="navelem"><a class="el" href="dir_e155a64606be01e9718a8b1197c63fff.html">Boot</a></li><li class="navelem"><a class="el" href="dir_08690fdcb6b3138c931f33749be09044.html">include</a></li><li class="navelem"><a class="el" href="dir_b641ebb3d870e3bbb06aca4db697d2ea.html">Protocol</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">MpService.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="MpService_8h__dep__incl.png" border="0" usemap="#aXenevaOS_2Boot_2include_2Protocol_2MpService_8hdep" alt=""/></div>
<map name="aXenevaOS_2Boot_2include_2Protocol_2MpService_8hdep" id="aXenevaOS_2Boot_2include_2Protocol_2MpService_8hdep">
<area shape="rect" title=" " alt="" coords="5,5,180,45"/>
<area shape="rect" href="MpServices_8h.html" title=" " alt="" coords="5,93,180,133"/>
<area shape="poly" title=" " alt="" coords="95,59,95,93,90,93,90,59"/>
</map>
</div>
</div>
<p><a href="MpService_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEFI__CPU__PHYSICAL__LOCATION.html">EFI_CPU_PHYSICAL_LOCATION</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEFI__PROCESSOR__INFORMATION.html">EFI_PROCESSOR_INFORMATION</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__EFI__MP__SERVICES__PROTOCOL.html">_EFI_MP_SERVICES_PROTOCOL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a57480dcf477585b836eb9d73da1a0eaa" id="r_a57480dcf477585b836eb9d73da1a0eaa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MpService_8h.html#a57480dcf477585b836eb9d73da1a0eaa">EFI_MP_SERVICES_PROTOCOL_GUID</a></td></tr>
<tr class="separator:a57480dcf477585b836eb9d73da1a0eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109a2fe493bc8647513673a63bcc790d" id="r_a109a2fe493bc8647513673a63bcc790d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MpService_8h.html#a109a2fe493bc8647513673a63bcc790d">END_OF_CPU_LIST</a>&#160;&#160;&#160;0xffffffff</td></tr>
<tr class="separator:a109a2fe493bc8647513673a63bcc790d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ad311602617250aebc4349c3ed4095" id="r_aa4ad311602617250aebc4349c3ed4095"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MpService_8h.html#aa4ad311602617250aebc4349c3ed4095">PROCESSOR_AS_BSP_BIT</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="separator:aa4ad311602617250aebc4349c3ed4095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71580b95c200041d3b9141572538880" id="r_af71580b95c200041d3b9141572538880"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MpService_8h.html#af71580b95c200041d3b9141572538880">PROCESSOR_ENABLED_BIT</a>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="separator:af71580b95c200041d3b9141572538880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a9812a74077655a0925b86efd68a66" id="r_a45a9812a74077655a0925b86efd68a66"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MpService_8h.html#a45a9812a74077655a0925b86efd68a66">PROCESSOR_HEALTH_STATUS_BIT</a>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="separator:a45a9812a74077655a0925b86efd68a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2396a2ef8be07e2fd00d821c02a78ce7" id="r_a2396a2ef8be07e2fd00d821c02a78ce7"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__EFI__MP__SERVICES__PROTOCOL.html">_EFI_MP_SERVICES_PROTOCOL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MpService_8h.html#a2396a2ef8be07e2fd00d821c02a78ce7">EFI_MP_SERVICES_PROTOCOL</a></td></tr>
<tr class="separator:a2396a2ef8be07e2fd00d821c02a78ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac148b2abb07c54e343434ee310c2c4af" id="r_ac148b2abb07c54e343434ee310c2c4af"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MpService_8h.html#ac148b2abb07c54e343434ee310c2c4af">EFI_MP_SERVICES_GET_NUMBER_OF_PROCESSORS</a>) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="MpService_8h.html#a2396a2ef8be07e2fd00d821c02a78ce7">EFI_MP_SERVICES_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *NumberOfProcessors, <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *NumberOfEnabledProcessors)</td></tr>
<tr class="separator:ac148b2abb07c54e343434ee310c2c4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27994496bdbca794b90e8ac082ca6dc" id="r_ae27994496bdbca794b90e8ac082ca6dc"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MpService_8h.html#ae27994496bdbca794b90e8ac082ca6dc">EFI_MP_SERVICES_GET_PROCESSOR_INFO</a>) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="MpService_8h.html#a2396a2ef8be07e2fd00d821c02a78ce7">EFI_MP_SERVICES_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> ProcessorNumber, <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="structEFI__PROCESSOR__INFORMATION.html">EFI_PROCESSOR_INFORMATION</a> *ProcessorInfoBuffer)</td></tr>
<tr class="separator:ae27994496bdbca794b90e8ac082ca6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f47d17d7b24c7b310526f09fda9c05" id="r_a79f47d17d7b24c7b310526f09fda9c05"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MpService_8h.html#a79f47d17d7b24c7b310526f09fda9c05">EFI_MP_SERVICES_STARTUP_ALL_APS</a>) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="MpService_8h.html#a2396a2ef8be07e2fd00d821c02a78ce7">EFI_MP_SERVICES_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="PiMultiPhase_8h.html#a05411c9b170947cbb1c297ac705e183e">EFI_AP_PROCEDURE</a> Procedure, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="actypes_8h.html#a112e3146cb38b6ee95e64d85842e380a">BOOLEAN</a> SingleThread, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="UefiBaseType_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> WaitEvent <a class="el" href="Base_8h.html#afdff552467cc2d2d5815831e9656cffc">OPTIONAL</a>, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> TimeoutInMicroSeconds, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="acefi_8h.html#a7f319bfc2492a2136964194204e7a8cf">VOID</a> *ProcedureArgument <a class="el" href="Base_8h.html#afdff552467cc2d2d5815831e9656cffc">OPTIONAL</a>, <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> **FailedCpuList <a class="el" href="Base_8h.html#afdff552467cc2d2d5815831e9656cffc">OPTIONAL</a>)</td></tr>
<tr class="separator:a79f47d17d7b24c7b310526f09fda9c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f64f76450a89891dd2d3cc4fdece2fa" id="r_a4f64f76450a89891dd2d3cc4fdece2fa"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MpService_8h.html#a4f64f76450a89891dd2d3cc4fdece2fa">EFI_MP_SERVICES_STARTUP_THIS_AP</a>) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="MpService_8h.html#a2396a2ef8be07e2fd00d821c02a78ce7">EFI_MP_SERVICES_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="PiMultiPhase_8h.html#a05411c9b170947cbb1c297ac705e183e">EFI_AP_PROCEDURE</a> Procedure, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> ProcessorNumber, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="UefiBaseType_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> WaitEvent <a class="el" href="Base_8h.html#afdff552467cc2d2d5815831e9656cffc">OPTIONAL</a>, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> TimeoutInMicroseconds, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="acefi_8h.html#a7f319bfc2492a2136964194204e7a8cf">VOID</a> *ProcedureArgument <a class="el" href="Base_8h.html#afdff552467cc2d2d5815831e9656cffc">OPTIONAL</a>, <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="actypes_8h.html#a112e3146cb38b6ee95e64d85842e380a">BOOLEAN</a> *Finished <a class="el" href="Base_8h.html#afdff552467cc2d2d5815831e9656cffc">OPTIONAL</a>)</td></tr>
<tr class="separator:a4f64f76450a89891dd2d3cc4fdece2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c417042175a154a4d6a001e00bd5c4" id="r_ab3c417042175a154a4d6a001e00bd5c4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MpService_8h.html#ab3c417042175a154a4d6a001e00bd5c4">EFI_MP_SERVICES_SWITCH_BSP</a>) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="MpService_8h.html#a2396a2ef8be07e2fd00d821c02a78ce7">EFI_MP_SERVICES_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> ProcessorNumber, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="actypes_8h.html#a112e3146cb38b6ee95e64d85842e380a">BOOLEAN</a> EnableOldBSP)</td></tr>
<tr class="separator:ab3c417042175a154a4d6a001e00bd5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfe8b82bd404b58508518ad90d91df2" id="r_a2bfe8b82bd404b58508518ad90d91df2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MpService_8h.html#a2bfe8b82bd404b58508518ad90d91df2">EFI_MP_SERVICES_ENABLEDISABLEAP</a>) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="MpService_8h.html#a2396a2ef8be07e2fd00d821c02a78ce7">EFI_MP_SERVICES_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> ProcessorNumber, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="actypes_8h.html#a112e3146cb38b6ee95e64d85842e380a">BOOLEAN</a> EnableAP, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> *HealthFlag <a class="el" href="Base_8h.html#afdff552467cc2d2d5815831e9656cffc">OPTIONAL</a>)</td></tr>
<tr class="separator:a2bfe8b82bd404b58508518ad90d91df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f524efdeb3d1651705314a786cbe41c" id="r_a0f524efdeb3d1651705314a786cbe41c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MpService_8h.html#a0f524efdeb3d1651705314a786cbe41c">EFI_MP_SERVICES_WHOAMI</a>) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="MpService_8h.html#a2396a2ef8be07e2fd00d821c02a78ce7">EFI_MP_SERVICES_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *ProcessorNumber)</td></tr>
<tr class="separator:a0f524efdeb3d1651705314a786cbe41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac35d1f1be0f26ebd56019f9d13059fae" id="r_ac35d1f1be0f26ebd56019f9d13059fae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="UefiBaseType_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MpService_8h.html#ac35d1f1be0f26ebd56019f9d13059fae">gEfiMpServiceProtocolGuid</a></td></tr>
<tr class="separator:ac35d1f1be0f26ebd56019f9d13059fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>When installed, the MP Services Protocol produces a collection of services that are needed for MP management.</p>
<p>The MP Services Protocol provides a generalized way of performing following tasks:</p><ul>
<li>Retrieving information of multi-processor environment and MP-related status of specific processors.</li>
<li>Dispatching user-provided function to APs.</li>
<li>Maintain MP-related processor status.</li>
</ul>
<p>The MP Services Protocol must be produced on any system with more than one logical processor.</p>
<p>The Protocol is available only during boot time.</p>
<p>MP Services Protocol is hardware-independent. Most of the logic of this protocol is architecturally neutral. It abstracts the multi-processor environment and status of processors, and provides interfaces to retrieve information, maintain, and dispatch.</p>
<p>MP Services Protocol may be consumed by ACPI module. The ACPI module may use this protocol to retrieve data that are needed for an MP platform and report them to OS. MP Services Protocol may also be used to program and configure processors, such as MTRR synchronization for memory space attributes setting in DXE Services. MP Services Protocol may be used by non-CPU DXE drivers to speed up platform boot by taking advantage of the processing capabilities of the APs, for example, using APs to help test system memory in parallel with other device initialization. Diagnostics applications may also use this protocol for multi-processor.</p>
<p>Copyright (c) 2006 - 2017, Intel Corporation. All rights reserved.<br  />
 This program and the accompanying materials are licensed and made available under the terms and conditions of the BSD License that accompanies this distribution. The full text of the license may be found at <a href="http://opensource.org/licenses/bsd-license.php">http://opensource.org/licenses/bsd-license.php</a>.</p>
<p>THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.</p>
<dl class="section user"><dt>Revision Reference:</dt><dd>This Protocol is defined in the UEFI Platform Initialization Specification 1.2, Volume 2:Driver Execution Environment Core Interface. </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a57480dcf477585b836eb9d73da1a0eaa" name="a57480dcf477585b836eb9d73da1a0eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57480dcf477585b836eb9d73da1a0eaa">&#9670;&#160;</a></span>EFI_MP_SERVICES_PROTOCOL_GUID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_MP_SERVICES_PROTOCOL_GUID</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  { \</div>
<div class="line">    0x3fdda605, 0xa76e, 0x4f46, {0xad, 0x29, 0x12, 0xf4, 0x53, 0x1b, 0x3d, 0x08} \</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Global ID for the EFI_MP_SERVICES_PROTOCOL. </p>

</div>
</div>
<a id="a109a2fe493bc8647513673a63bcc790d" name="a109a2fe493bc8647513673a63bcc790d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109a2fe493bc8647513673a63bcc790d">&#9670;&#160;</a></span>END_OF_CPU_LIST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define END_OF_CPU_LIST&#160;&#160;&#160;0xffffffff</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Terminator for a list of failed CPUs returned by StartAllAPs(). </p>

</div>
</div>
<a id="aa4ad311602617250aebc4349c3ed4095" name="aa4ad311602617250aebc4349c3ed4095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ad311602617250aebc4349c3ed4095">&#9670;&#160;</a></span>PROCESSOR_AS_BSP_BIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PROCESSOR_AS_BSP_BIT&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This bit is used in the StatusFlag field of <a class="el" href="structEFI__PROCESSOR__INFORMATION.html">EFI_PROCESSOR_INFORMATION</a> and indicates whether the processor is playing the role of BSP. If the bit is 1, then the processor is BSP. Otherwise, it is AP. </p>

</div>
</div>
<a id="af71580b95c200041d3b9141572538880" name="af71580b95c200041d3b9141572538880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71580b95c200041d3b9141572538880">&#9670;&#160;</a></span>PROCESSOR_ENABLED_BIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PROCESSOR_ENABLED_BIT&#160;&#160;&#160;0x00000002</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This bit is used in the StatusFlag field of <a class="el" href="structEFI__PROCESSOR__INFORMATION.html">EFI_PROCESSOR_INFORMATION</a> and indicates whether the processor is enabled. If the bit is 1, then the processor is enabled. Otherwise, it is disabled. </p>

</div>
</div>
<a id="a45a9812a74077655a0925b86efd68a66" name="a45a9812a74077655a0925b86efd68a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a9812a74077655a0925b86efd68a66">&#9670;&#160;</a></span>PROCESSOR_HEALTH_STATUS_BIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PROCESSOR_HEALTH_STATUS_BIT&#160;&#160;&#160;0x00000004</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This bit is used in the StatusFlag field of <a class="el" href="structEFI__PROCESSOR__INFORMATION.html">EFI_PROCESSOR_INFORMATION</a> and indicates whether the processor is healthy. If the bit is 1, then the processor is healthy. Otherwise, some fault has been detected for the processor. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a2bfe8b82bd404b58508518ad90d91df2" name="a2bfe8b82bd404b58508518ad90d91df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bfe8b82bd404b58508518ad90d91df2">&#9670;&#160;</a></span>EFI_MP_SERVICES_ENABLEDISABLEAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_MP_SERVICES_ENABLEDISABLEAP) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="MpService_8h.html#a2396a2ef8be07e2fd00d821c02a78ce7">EFI_MP_SERVICES_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> ProcessorNumber, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="actypes_8h.html#a112e3146cb38b6ee95e64d85842e380a">BOOLEAN</a> EnableAP, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> *HealthFlag <a class="el" href="Base_8h.html#afdff552467cc2d2d5815831e9656cffc">OPTIONAL</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This service lets the caller enable or disable an AP from this point onward. This service may only be called from the BSP.</p>
<p>This service allows the caller enable or disable an AP from this point onward. The caller can optionally specify the health status of the AP by Health. If an AP is being disabled, then the state of the disabled AP is implementation dependent. If an AP is enabled, then the implementation must guarantee that a complete initialization sequence is performed on the AP, so the AP is in a state that is compatible with an MP operating system. This service may not be supported after the UEFI Event EFI_EVENT_GROUP_READY_TO_BOOT is signaled.</p>
<p>If the enable or disable AP operation cannot be completed prior to the return from this service, then EFI_UNSUPPORTED must be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_MP_SERVICES_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcessorNumber</td><td>The handle number of AP. The range is from 0 to the total number of logical processors minus 1. The total number of logical processors can be retrieved by <a class="el" href="struct__EFI__MP__SERVICES__PROTOCOL.html#aa12e7ba3dd2d4e674770fbc652ff6985">EFI_MP_SERVICES_PROTOCOL.GetNumberOfProcessors()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EnableAP</td><td>Specifies the new state for the processor for enabled, FALSE for disabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">HealthFlag</td><td>If not NULL, a pointer to a value that specifies the new health status of the AP. This flag corresponds to StatusFlag defined in <a class="el" href="struct__EFI__MP__SERVICES__PROTOCOL.html#aae39ebe24639e290b4ed80db0ba1fb85">EFI_MP_SERVICES_PROTOCOL.GetProcessorInfo()</a>. Only the PROCESSOR_HEALTH_STATUS_BIT is used. All other bits are ignored. If it is NULL, this parameter is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The specified AP was enabled or disabled successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Enabling or disabling an AP cannot be completed prior to this service returning. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Enabling or disabling an AP is not supported. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The calling processor is an AP. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>Processor with the handle specified by ProcessorNumber does not exist. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ProcessorNumber specifies the BSP. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac148b2abb07c54e343434ee310c2c4af" name="ac148b2abb07c54e343434ee310c2c4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac148b2abb07c54e343434ee310c2c4af">&#9670;&#160;</a></span>EFI_MP_SERVICES_GET_NUMBER_OF_PROCESSORS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_MP_SERVICES_GET_NUMBER_OF_PROCESSORS) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="MpService_8h.html#a2396a2ef8be07e2fd00d821c02a78ce7">EFI_MP_SERVICES_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *NumberOfProcessors, <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *NumberOfEnabledProcessors)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This service retrieves the number of logical processor in the platform and the number of those logical processors that are enabled on this boot. This service may only be called from the BSP.</p>
<p>This function is used to retrieve the following information:</p><ul>
<li>The number of logical processors that are present in the system.</li>
<li>The number of enabled logical processors in the system at the instant this call is made.</li>
</ul>
<p>Because MP Service Protocol provides services to enable and disable processors dynamically, the number of enabled logical processors may vary during the course of a boot session.</p>
<p>If this service is called from an AP, then EFI_DEVICE_ERROR is returned. If NumberOfProcessors or NumberOfEnabledProcessors is NULL, then EFI_INVALID_PARAMETER is returned. Otherwise, the total number of processors is returned in NumberOfProcessors, the number of currently enabled processor is returned in NumberOfEnabledProcessors, and EFI_SUCCESS is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_MP_SERVICES_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NumberOfProcessors</td><td>Pointer to the total number of logical processors in the system, including the BSP and disabled APs. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NumberOfEnabledProcessors</td><td>Pointer to the number of enabled logical processors that exist in system, including the BSP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The number of logical processors and enabled logical processors was retrieved. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The calling processor is an AP. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>NumberOfProcessors is NULL. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>NumberOfEnabledProcessors is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae27994496bdbca794b90e8ac082ca6dc" name="ae27994496bdbca794b90e8ac082ca6dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27994496bdbca794b90e8ac082ca6dc">&#9670;&#160;</a></span>EFI_MP_SERVICES_GET_PROCESSOR_INFO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_MP_SERVICES_GET_PROCESSOR_INFO) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="MpService_8h.html#a2396a2ef8be07e2fd00d821c02a78ce7">EFI_MP_SERVICES_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> ProcessorNumber, <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="structEFI__PROCESSOR__INFORMATION.html">EFI_PROCESSOR_INFORMATION</a> *ProcessorInfoBuffer)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets detailed MP-related information on the requested processor at the instant this call is made. This service may only be called from the BSP.</p>
<p>This service retrieves detailed MP-related information about any processor on the platform. Note the following:</p><ul>
<li>The processor information may change during the course of a boot session.</li>
<li>The information presented here is entirely MP related.</li>
</ul>
<p>Information regarding the number of caches and their sizes, frequency of operation, slot numbers is all considered platform-related information and is not provided by this service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_MP_SERVICES_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcessorNumber</td><td>The handle number of processor. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ProcessorInfoBuffer</td><td>A pointer to the buffer where information for the requested processor is deposited.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>Processor information was returned. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The calling processor is an AP. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ProcessorInfoBuffer is NULL. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The processor with the handle specified by ProcessorNumber does not exist in the platform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2396a2ef8be07e2fd00d821c02a78ce7" name="a2396a2ef8be07e2fd00d821c02a78ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2396a2ef8be07e2fd00d821c02a78ce7">&#9670;&#160;</a></span>EFI_MP_SERVICES_PROTOCOL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__EFI__MP__SERVICES__PROTOCOL.html">_EFI_MP_SERVICES_PROTOCOL</a> <a class="el" href="MpService_8h.html#a2396a2ef8be07e2fd00d821c02a78ce7">EFI_MP_SERVICES_PROTOCOL</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forward declaration for the EFI_MP_SERVICES_PROTOCOL. </p>

</div>
</div>
<a id="a79f47d17d7b24c7b310526f09fda9c05" name="a79f47d17d7b24c7b310526f09fda9c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f47d17d7b24c7b310526f09fda9c05">&#9670;&#160;</a></span>EFI_MP_SERVICES_STARTUP_ALL_APS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_MP_SERVICES_STARTUP_ALL_APS) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="MpService_8h.html#a2396a2ef8be07e2fd00d821c02a78ce7">EFI_MP_SERVICES_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="PiMultiPhase_8h.html#a05411c9b170947cbb1c297ac705e183e">EFI_AP_PROCEDURE</a> Procedure, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="actypes_8h.html#a112e3146cb38b6ee95e64d85842e380a">BOOLEAN</a> SingleThread, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="UefiBaseType_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> WaitEvent <a class="el" href="Base_8h.html#afdff552467cc2d2d5815831e9656cffc">OPTIONAL</a>, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> TimeoutInMicroSeconds, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="acefi_8h.html#a7f319bfc2492a2136964194204e7a8cf">VOID</a> *ProcedureArgument <a class="el" href="Base_8h.html#afdff552467cc2d2d5815831e9656cffc">OPTIONAL</a>, <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> **FailedCpuList <a class="el" href="Base_8h.html#afdff552467cc2d2d5815831e9656cffc">OPTIONAL</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This service executes a caller provided function on all enabled APs. APs can run either simultaneously or one at a time in sequence. This service supports both blocking and non-blocking requests. The non-blocking requests use EFI events so the BSP can detect when the APs have finished. This service may only be called from the BSP.</p>
<p>This function is used to dispatch all the enabled APs to the function specified by Procedure. If any enabled AP is busy, then EFI_NOT_READY is returned immediately and Procedure is not started on any AP.</p>
<p>If SingleThread is TRUE, all the enabled APs execute the function specified by Procedure one by one, in ascending order of processor handle number. Otherwise, all the enabled APs execute the function specified by Procedure simultaneously.</p>
<p>If WaitEvent is NULL, execution is in blocking mode. The BSP waits until all APs finish or TimeoutInMicroSecs expires. Otherwise, execution is in non-blocking mode, and the BSP returns from this service without waiting for APs. If a non-blocking mode is requested after the UEFI Event EFI_EVENT_GROUP_READY_TO_BOOT is signaled, then EFI_UNSUPPORTED must be returned.</p>
<p>If the timeout specified by TimeoutInMicroseconds expires before all APs return from Procedure, then Procedure on the failed APs is terminated. All enabled APs are always available for further calls to <a class="el" href="struct__EFI__MP__SERVICES__PROTOCOL.html#aad259e733022495f164a13780d650f78">EFI_MP_SERVICES_PROTOCOL.StartupAllAPs()</a> and <a class="el" href="struct__EFI__MP__SERVICES__PROTOCOL.html#aaf5bdbd816e35fdc57b2a8176f3f1ed3">EFI_MP_SERVICES_PROTOCOL.StartupThisAP()</a>. If FailedCpuList is not NULL, its content points to the list of processor handle numbers in which Procedure was terminated.</p>
<p>Note: It is the responsibility of the consumer of the <a class="el" href="struct__EFI__MP__SERVICES__PROTOCOL.html#aad259e733022495f164a13780d650f78">EFI_MP_SERVICES_PROTOCOL.StartupAllAPs()</a> to make sure that the nature of the code that is executed on the BSP and the dispatched APs is well controlled. The MP Services Protocol does not guarantee that the Procedure function is MP-safe. Hence, the tasks that can be run in parallel are limited to certain independent tasks and well-controlled exclusive code. EFI services and protocols may not be called by APs unless otherwise specified.</p>
<p>In blocking execution mode, BSP waits until all APs finish or TimeoutInMicroSeconds expires.</p>
<p>In non-blocking execution mode, BSP is freed to return to the caller and then proceed to the next task without having to wait for APs. The following sequence needs to occur in a non-blocking execution mode:</p>
<ol type="1">
<li>The caller that intends to use this MP Services Protocol in non-blocking mode creates WaitEvent by calling the EFI CreateEvent() service. The caller invokes <a class="el" href="struct__EFI__MP__SERVICES__PROTOCOL.html#aad259e733022495f164a13780d650f78">EFI_MP_SERVICES_PROTOCOL.StartupAllAPs()</a>. If the parameter WaitEvent is not NULL, then StartupAllAPs() executes in non-blocking mode. It requests the function specified by Procedure to be started on all the enabled APs, and releases the BSP to continue with other tasks.</li>
<li>The caller can use the CheckEvent() and WaitForEvent() services to check the state of the WaitEvent created in step 1.</li>
<li>When the APs complete their task or TimeoutInMicroSecondss expires, the MP Service signals WaitEvent by calling the EFI SignalEvent() function. If FailedCpuList is not NULL, its content is available when WaitEvent is signaled. If all APs returned from Procedure prior to the timeout, then FailedCpuList is set to NULL. If not all APs return from Procedure before the timeout, then FailedCpuList is filled in with the list of the failed APs. The buffer is allocated by MP Service Protocol using <a class="el" href="MemoryAllocationLib_8h.html#a1c677b257b7d0e9fee0ac869947c5606">AllocatePool()</a>. It is the caller's responsibility to free the buffer with <a class="el" href="MemoryAllocationLib_8h.html#a8b1cbc21e0cebcfc6a992546ec9b4941">FreePool()</a> service.</li>
<li>This invocation of SignalEvent() function informs the caller that invoked <a class="el" href="struct__EFI__MP__SERVICES__PROTOCOL.html#aad259e733022495f164a13780d650f78">EFI_MP_SERVICES_PROTOCOL.StartupAllAPs()</a> that either all the APs completed the specified task or a timeout occurred. The contents of FailedCpuList can be examined to determine which APs did not complete the specified task prior to the timeout.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_MP_SERVICES_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Procedure</td><td>A pointer to the function to be run on enabled APs of the system. See type EFI_AP_PROCEDURE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SingleThread</td><td>If TRUE, then all the enabled APs execute the function specified by Procedure one by one, in ascending order of processor handle number. If FALSE, then all the enabled APs execute the function specified by Procedure simultaneously. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WaitEvent</td><td>The event created by the caller with CreateEvent() service. If it is NULL, then execute in blocking mode. BSP waits until all APs finish or TimeoutInMicroSeconds expires. If it's not NULL, then execute in non-blocking mode. BSP requests the function specified by Procedure to be started on all the enabled APs, and go on executing immediately. If all return from Procedure, or TimeoutInMicroSeconds expires, this event is signaled. The BSP can use the CheckEvent() or WaitForEvent() services to check the state of event. Type EFI_EVENT is defined in CreateEvent() in the Unified Extensible Firmware Interface Specification. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TimeoutInMicrosecsond</td><td>Indicates the time limit in microseconds for APs to return from Procedure, either for blocking or non-blocking mode. Zero means infinity. If the timeout expires before all APs return from Procedure, then Procedure on the failed APs is terminated. All enabled APs are available for next function assigned by <a class="el" href="struct__EFI__MP__SERVICES__PROTOCOL.html#aad259e733022495f164a13780d650f78">EFI_MP_SERVICES_PROTOCOL.StartupAllAPs()</a> or <a class="el" href="struct__EFI__MP__SERVICES__PROTOCOL.html#aaf5bdbd816e35fdc57b2a8176f3f1ed3">EFI_MP_SERVICES_PROTOCOL.StartupThisAP()</a>. If the timeout expires in blocking mode, BSP returns EFI_TIMEOUT. If the timeout expires in non-blocking mode, WaitEvent is signaled with SignalEvent(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcedureArgument</td><td>The parameter passed into Procedure for all APs. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FailedCpuList</td><td>If NULL, this parameter is ignored. Otherwise, if all APs finish successfully, then its content is set to NULL. If not all APs finish before timeout expires, then its content is set to address of the buffer holding handle numbers of the failed APs. The buffer is allocated by MP Service Protocol, and it's the caller's responsibility to free the buffer with <a class="el" href="MemoryAllocationLib_8h.html#a8b1cbc21e0cebcfc6a992546ec9b4941">FreePool()</a> service. In blocking mode, it is ready for consumption when the call returns. In non-blocking mode, it is ready when WaitEvent is signaled. The list of failed CPU is terminated by END_OF_CPU_LIST.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>In blocking mode, all APs have finished before the timeout expired. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>In non-blocking mode, function has been dispatched to all enabled APs. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>A non-blocking mode request was made after the UEFI event EFI_EVENT_GROUP_READY_TO_BOOT was signaled. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>Caller processor is AP. </td></tr>
    <tr><td class="paramname">EFI_NOT_STARTED</td><td>No enabled APs exist in the system. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>Any enabled APs are busy. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>In blocking mode, the timeout expired before all enabled APs have finished. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Procedure is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f64f76450a89891dd2d3cc4fdece2fa" name="a4f64f76450a89891dd2d3cc4fdece2fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f64f76450a89891dd2d3cc4fdece2fa">&#9670;&#160;</a></span>EFI_MP_SERVICES_STARTUP_THIS_AP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_MP_SERVICES_STARTUP_THIS_AP) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="MpService_8h.html#a2396a2ef8be07e2fd00d821c02a78ce7">EFI_MP_SERVICES_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="PiMultiPhase_8h.html#a05411c9b170947cbb1c297ac705e183e">EFI_AP_PROCEDURE</a> Procedure, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> ProcessorNumber, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="UefiBaseType_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> WaitEvent <a class="el" href="Base_8h.html#afdff552467cc2d2d5815831e9656cffc">OPTIONAL</a>, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> TimeoutInMicroseconds, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="acefi_8h.html#a7f319bfc2492a2136964194204e7a8cf">VOID</a> *ProcedureArgument <a class="el" href="Base_8h.html#afdff552467cc2d2d5815831e9656cffc">OPTIONAL</a>, <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="actypes_8h.html#a112e3146cb38b6ee95e64d85842e380a">BOOLEAN</a> *Finished <a class="el" href="Base_8h.html#afdff552467cc2d2d5815831e9656cffc">OPTIONAL</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This service lets the caller get one enabled AP to execute a caller-provided function. The caller can request the BSP to either wait for the completion of the AP or just proceed with the next task by using the EFI event mechanism. See <a class="el" href="struct__EFI__MP__SERVICES__PROTOCOL.html#aad259e733022495f164a13780d650f78">EFI_MP_SERVICES_PROTOCOL.StartupAllAPs()</a> for more details on non-blocking execution support. This service may only be called from the BSP.</p>
<p>This function is used to dispatch one enabled AP to the function specified by Procedure passing in the argument specified by ProcedureArgument. If WaitEvent is NULL, execution is in blocking mode. The BSP waits until the AP finishes or TimeoutInMicroSecondss expires. Otherwise, execution is in non-blocking mode. BSP proceeds to the next task without waiting for the AP. If a non-blocking mode is requested after the UEFI Event EFI_EVENT_GROUP_READY_TO_BOOT is signaled, then EFI_UNSUPPORTED must be returned.</p>
<p>If the timeout specified by TimeoutInMicroseconds expires before the AP returns from Procedure, then execution of Procedure by the AP is terminated. The AP is available for subsequent calls to <a class="el" href="struct__EFI__MP__SERVICES__PROTOCOL.html#aad259e733022495f164a13780d650f78">EFI_MP_SERVICES_PROTOCOL.StartupAllAPs()</a> and <a class="el" href="struct__EFI__MP__SERVICES__PROTOCOL.html#aaf5bdbd816e35fdc57b2a8176f3f1ed3">EFI_MP_SERVICES_PROTOCOL.StartupThisAP()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_MP_SERVICES_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Procedure</td><td>A pointer to the function to be run on the designated AP of the system. See type EFI_AP_PROCEDURE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcessorNumber</td><td>The handle number of the AP. The range is from 0 to the total number of logical processors minus 1. The total number of logical processors can be retrieved by <a class="el" href="struct__EFI__MP__SERVICES__PROTOCOL.html#aa12e7ba3dd2d4e674770fbc652ff6985">EFI_MP_SERVICES_PROTOCOL.GetNumberOfProcessors()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WaitEvent</td><td>The event created by the caller with CreateEvent() service. If it is NULL, then execute in blocking mode. BSP waits until this AP finish or TimeoutInMicroSeconds expires. If it's not NULL, then execute in non-blocking mode. BSP requests the function specified by Procedure to be started on this AP, and go on executing immediately. If this AP return from Procedure or TimeoutInMicroSeconds expires, this event is signaled. The BSP can use the CheckEvent() or WaitForEvent() services to check the state of event. Type EFI_EVENT is defined in CreateEvent() in the Unified Extensible Firmware Interface Specification. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TimeoutInMicrosecsond</td><td>Indicates the time limit in microseconds for this AP to finish this Procedure, either for blocking or non-blocking mode. Zero means infinity. If the timeout expires before this AP returns from Procedure, then Procedure on the AP is terminated. The AP is available for next function assigned by <a class="el" href="struct__EFI__MP__SERVICES__PROTOCOL.html#aad259e733022495f164a13780d650f78">EFI_MP_SERVICES_PROTOCOL.StartupAllAPs()</a> or <a class="el" href="struct__EFI__MP__SERVICES__PROTOCOL.html#aaf5bdbd816e35fdc57b2a8176f3f1ed3">EFI_MP_SERVICES_PROTOCOL.StartupThisAP()</a>. If the timeout expires in blocking mode, BSP returns EFI_TIMEOUT. If the timeout expires in non-blocking mode, WaitEvent is signaled with SignalEvent(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcedureArgument</td><td>The parameter passed into Procedure on the specified AP. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Finished</td><td>If NULL, this parameter is ignored. In blocking mode, this parameter is ignored. In non-blocking mode, if AP returns from Procedure before the timeout expires, its content is set to TRUE. Otherwise, the value is set to FALSE. The caller can determine if the AP returned from Procedure by evaluating this value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>In blocking mode, specified AP finished before the timeout expires. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>In non-blocking mode, the function has been dispatched to specified AP. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>A non-blocking mode request was made after the UEFI event EFI_EVENT_GROUP_READY_TO_BOOT was signaled. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The calling processor is an AP. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>In blocking mode, the timeout expired before the specified AP has finished. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The specified AP is busy. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The processor with the handle specified by ProcessorNumber does not exist. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ProcessorNumber specifies the BSP or disabled AP. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>Procedure is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3c417042175a154a4d6a001e00bd5c4" name="ab3c417042175a154a4d6a001e00bd5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c417042175a154a4d6a001e00bd5c4">&#9670;&#160;</a></span>EFI_MP_SERVICES_SWITCH_BSP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_MP_SERVICES_SWITCH_BSP) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="MpService_8h.html#a2396a2ef8be07e2fd00d821c02a78ce7">EFI_MP_SERVICES_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> ProcessorNumber, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="actypes_8h.html#a112e3146cb38b6ee95e64d85842e380a">BOOLEAN</a> EnableOldBSP)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This service switches the requested AP to be the BSP from that point onward. This service changes the BSP for all purposes. This call can only be performed by the current BSP.</p>
<p>This service switches the requested AP to be the BSP from that point onward. This service changes the BSP for all purposes. The new BSP can take over the execution of the old BSP and continue seamlessly from where the old one left off. This service may not be supported after the UEFI Event EFI_EVENT_GROUP_READY_TO_BOOT is signaled.</p>
<p>If the BSP cannot be switched prior to the return from this service, then EFI_UNSUPPORTED must be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_MP_SERVICES_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcessorNumber</td><td>The handle number of AP that is to become the new BSP. The range is from 0 to the total number of logical processors minus 1. The total number of logical processors can be retrieved by <a class="el" href="struct__EFI__MP__SERVICES__PROTOCOL.html#aa12e7ba3dd2d4e674770fbc652ff6985">EFI_MP_SERVICES_PROTOCOL.GetNumberOfProcessors()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EnableOldBSP</td><td>If TRUE, then the old BSP will be listed as an enabled AP. Otherwise, it will be disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>BSP successfully switched. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Switching the BSP cannot be completed prior to this service returning. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>Switching the BSP is not supported. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The calling processor is an AP. </td></tr>
    <tr><td class="paramname">EFI_NOT_FOUND</td><td>The processor with the handle specified by ProcessorNumber does not exist. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ProcessorNumber specifies the current BSP or a disabled AP. </td></tr>
    <tr><td class="paramname">EFI_NOT_READY</td><td>The specified AP is busy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f524efdeb3d1651705314a786cbe41c" name="a0f524efdeb3d1651705314a786cbe41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f524efdeb3d1651705314a786cbe41c">&#9670;&#160;</a></span>EFI_MP_SERVICES_WHOAMI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_MP_SERVICES_WHOAMI) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="MpService_8h.html#a2396a2ef8be07e2fd00d821c02a78ce7">EFI_MP_SERVICES_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *ProcessorNumber)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This return the handle number for the calling processor. This service may be called from the BSP and APs.</p>
<p>This service returns the processor handle number for the calling processor. The returned value is in the range from 0 to the total number of logical processors minus 1. The total number of logical processors can be retrieved with <a class="el" href="struct__EFI__MP__SERVICES__PROTOCOL.html#aa12e7ba3dd2d4e674770fbc652ff6985">EFI_MP_SERVICES_PROTOCOL.GetNumberOfProcessors()</a>. This service may be called from the BSP and APs. If ProcessorNumber is NULL, then EFI_INVALID_PARAMETER is returned. Otherwise, the current processors handle number is returned in ProcessorNumber, and EFI_SUCCESS is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>A pointer to the EFI_MP_SERVICES_PROTOCOL instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ProcessorNumber</td><td>Pointer to the handle number of AP. The range is from 0 to the total number of logical processors minus 1. The total number of logical processors can be retrieved by <a class="el" href="struct__EFI__MP__SERVICES__PROTOCOL.html#aa12e7ba3dd2d4e674770fbc652ff6985">EFI_MP_SERVICES_PROTOCOL.GetNumberOfProcessors()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The current processor handle number was returned in ProcessorNumber. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>ProcessorNumber is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac35d1f1be0f26ebd56019f9d13059fae" name="ac35d1f1be0f26ebd56019f9d13059fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac35d1f1be0f26ebd56019f9d13059fae">&#9670;&#160;</a></span>gEfiMpServiceProtocolGuid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="UefiBaseType_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> gEfiMpServiceProtocolGuid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
