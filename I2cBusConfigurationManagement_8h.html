<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XenevaOS: XenevaOS/Boot/include/Protocol/I2cBusConfigurationManagement.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">XenevaOS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_6f7cbf0a11b44b0a43b1ec16e930d793.html">XenevaOS</a></li><li class="navelem"><a class="el" href="dir_e155a64606be01e9718a8b1197c63fff.html">Boot</a></li><li class="navelem"><a class="el" href="dir_08690fdcb6b3138c931f33749be09044.html">include</a></li><li class="navelem"><a class="el" href="dir_b641ebb3d870e3bbb06aca4db697d2ea.html">Protocol</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">I2cBusConfigurationManagement.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a href="I2cBusConfigurationManagement_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__EFI__I2C__BUS__CONFIGURATION__MANAGEMENT__PROTOCOL.html">_EFI_I2C_BUS_CONFIGURATION_MANAGEMENT_PROTOCOL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a2b7f207cb0a2c0b518ab0c752fb925d9" id="r_a2b7f207cb0a2c0b518ab0c752fb925d9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="I2cBusConfigurationManagement_8h.html#a2b7f207cb0a2c0b518ab0c752fb925d9">EFI_I2C_BUS_CONFIGURATION_MANAGEMENT_PROTOCOL_GUID</a>&#160;&#160;&#160;  { 0x55b71fb5, 0x17c6, 0x410e, { 0xb5, 0xbd, 0x5f, 0xa2, 0xe3, 0xd4, 0x46, 0x6b }}</td></tr>
<tr class="separator:a2b7f207cb0a2c0b518ab0c752fb925d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a6fe24463fba8ba0d142b8c630710e710" id="r_a6fe24463fba8ba0d142b8c630710e710"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__EFI__I2C__BUS__CONFIGURATION__MANAGEMENT__PROTOCOL.html">_EFI_I2C_BUS_CONFIGURATION_MANAGEMENT_PROTOCOL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="I2cBusConfigurationManagement_8h.html#a6fe24463fba8ba0d142b8c630710e710">EFI_I2C_BUS_CONFIGURATION_MANAGEMENT_PROTOCOL</a></td></tr>
<tr class="separator:a6fe24463fba8ba0d142b8c630710e710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28036da922a5cfdeb16beaf0559a7e5" id="r_af28036da922a5cfdeb16beaf0559a7e5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="I2cBusConfigurationManagement_8h.html#af28036da922a5cfdeb16beaf0559a7e5">EFI_I2C_BUS_CONFIGURATION_MANAGEMENT_PROTOCOL_ENABLE_I2C_BUS_CONFIGURATION</a>) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="Base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="I2cBusConfigurationManagement_8h.html#a6fe24463fba8ba0d142b8c630710e710">EFI_I2C_BUS_CONFIGURATION_MANAGEMENT_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> I2cBusConfiguration, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="UefiBaseType_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> Event <a class="el" href="Base_8h.html#afdff552467cc2d2d5815831e9656cffc">OPTIONAL</a>, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> *I2cStatus <a class="el" href="Base_8h.html#afdff552467cc2d2d5815831e9656cffc">OPTIONAL</a>)</td></tr>
<tr class="separator:af28036da922a5cfdeb16beaf0559a7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8a062f9cd50e63d876c8fd48459ce8e6" id="r_a8a062f9cd50e63d876c8fd48459ce8e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="UefiBaseType_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="I2cBusConfigurationManagement_8h.html#a8a062f9cd50e63d876c8fd48459ce8e6">gEfiI2cBusConfigurationManagementProtocolGuid</a></td></tr>
<tr class="separator:a8a062f9cd50e63d876c8fd48459ce8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>I2C Bus Configuration Management Protocol as defined in the PI 1.3 specification.</p>
<p>The EFI I2C bus configuration management protocol provides platform specific services that allow the I2C host protocol to reconfigure the switches and multiplexers and set the clock frequency for the I2C bus. This protocol also enables the I2C host protocol to reset an I2C device which may be locking up the I2C bus by holding the clock or data line low.</p>
<p>Copyright (c) 2013 - 2018, Intel Corporation. All rights reserved.<br  />
 This program and the accompanying materials are licensed and made available under the terms and conditions of the BSD License which accompanies this distribution. The full text of the license may be found at <a href="http://opensource.org/licenses/bsd-license.php">http://opensource.org/licenses/bsd-license.php</a></p>
<p>THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.</p>
<dl class="section user"><dt>Revision Reference:</dt><dd>This protocol is from PI Version 1.3. </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a2b7f207cb0a2c0b518ab0c752fb925d9" name="a2b7f207cb0a2c0b518ab0c752fb925d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7f207cb0a2c0b518ab0c752fb925d9">&#9670;&#160;</a></span>EFI_I2C_BUS_CONFIGURATION_MANAGEMENT_PROTOCOL_GUID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_I2C_BUS_CONFIGURATION_MANAGEMENT_PROTOCOL_GUID&#160;&#160;&#160;  { 0x55b71fb5, 0x17c6, 0x410e, { 0xb5, 0xbd, 0x5f, 0xa2, 0xe3, 0xd4, 0x46, 0x6b }}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a6fe24463fba8ba0d142b8c630710e710" name="a6fe24463fba8ba0d142b8c630710e710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe24463fba8ba0d142b8c630710e710">&#9670;&#160;</a></span>EFI_I2C_BUS_CONFIGURATION_MANAGEMENT_PROTOCOL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__EFI__I2C__BUS__CONFIGURATION__MANAGEMENT__PROTOCOL.html">_EFI_I2C_BUS_CONFIGURATION_MANAGEMENT_PROTOCOL</a> <a class="el" href="I2cBusConfigurationManagement_8h.html#a6fe24463fba8ba0d142b8c630710e710">EFI_I2C_BUS_CONFIGURATION_MANAGEMENT_PROTOCOL</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C bus configuration management protocol</p>
<p>The EFI I2C bus configuration management protocol provides platform specific services that allow the I2C host protocol to reconfigure the switches and multiplexers and set the clock frequency for the I2C bus. This protocol also enables the I2C host protocol to reset an I2C device which may be locking up the I2C bus by holding the clock or data line low.</p>
<p>The I2C protocol stack uses the concept of an I2C bus configuration as a way to describe a particular state of the switches and multiplexers in the I2C bus.</p>
<p>A simple I2C bus does not have any multiplexers or switches is described to the I2C protocol stack with a single I2C bus configuration which specifies the I2C bus frequency.</p>
<p>An I2C bus with switches and multiplexers use an I2C bus configuration to describe each of the unique settings for the switches and multiplexers and the I2C bus frequency. However the I2C bus configuration management protocol only needs to define the I2C bus configurations that the software uses, which may be a subset of the total.</p>
<p>The I2C bus configuration description includes a list of I2C devices which may be accessed when this I2C bus configuration is enabled. I2C devices before a switch or multiplexer must be included in one I2C bus configuration while I2C devices after a switch or multiplexer are on another I2C bus configuration.</p>
<p>The I2C bus configuration management protocol is an optional protocol. When the I2C bus configuration protocol is not defined the I2C host protocol does not start and the I2C master protocol may be used for other purposes such as SMBus traffic. When the I2C bus configuration protocol is available, the I2C host protocol uses the I2C bus configuration protocol to call into the platform specific code to set the switches and multiplexers and set the maximum I2C bus frequency.</p>
<p>The platform designers determine the maximum I2C bus frequency by selecting a frequency which supports all of the I2C devices on the I2C bus for the setting of switches and multiplexers. The platform designers must validate this against the I2C device data sheets and any limits of the I2C controller or bus length.</p>
<p>During I2C device enumeration, the I2C bus driver retrieves the I2C bus configuration that must be used to perform I2C transactions to each I2C device. This I2C bus configuration value is passed into the I2C host protocol to identify the I2C bus configuration required to access a specific I2C device. The I2C host protocol calls EnableBusConfiguration() to set the switches and multiplexers in the I2C bus and the I2C clock frequency. The I2C host protocol may optimize calls to EnableBusConfiguration() by only making the call when the I2C bus configuration value changes between I2C requests.</p>
<p>When I2C transactions are required on the same I2C bus to change the state of multiplexers or switches, the I2C master protocol must be used to perform the necessary I2C transactions.</p>
<p>It is up to the platform specific code to choose the proper I2C bus configuration when ExitBootServices() is called. Some operating systems are not able to manage the I2C bus configurations and must use the I2C bus configuration that is established by the platform firmware before ExitBootServices() returns. </p>

</div>
</div>
<a id="af28036da922a5cfdeb16beaf0559a7e5" name="af28036da922a5cfdeb16beaf0559a7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af28036da922a5cfdeb16beaf0559a7e5">&#9670;&#160;</a></span>EFI_I2C_BUS_CONFIGURATION_MANAGEMENT_PROTOCOL_ENABLE_I2C_BUS_CONFIGURATION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_I2C_BUS_CONFIGURATION_MANAGEMENT_PROTOCOL_ENABLE_I2C_BUS_CONFIGURATION) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="Base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="I2cBusConfigurationManagement_8h.html#a6fe24463fba8ba0d142b8c630710e710">EFI_I2C_BUS_CONFIGURATION_MANAGEMENT_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> I2cBusConfiguration, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="UefiBaseType_8h.html#a7f3111de303d836d8d3711c39363f81a">EFI_EVENT</a> Event <a class="el" href="Base_8h.html#afdff552467cc2d2d5815831e9656cffc">OPTIONAL</a>, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a> *I2cStatus <a class="el" href="Base_8h.html#afdff552467cc2d2d5815831e9656cffc">OPTIONAL</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable access to an I2C bus configuration.</p>
<p>This routine must be called at or below TPL_NOTIFY. For synchronous requests this routine must be called at or below TPL_CALLBACK.</p>
<p>Reconfigure the switches and multiplexers in the I2C bus to enable access to a specific I2C bus configuration. Also select the maximum clock frequency for this I2C bus configuration.</p>
<p>This routine uses the I2C Master protocol to perform I2C transactions on the local bus. This eliminates any recursion in the I2C stack for configuration transactions on the same I2C bus. This works because the local I2C bus is idle while the I2C bus configuration is being enabled.</p>
<p>If I2C transactions must be performed on other I2C busses, then the EFI_I2C_HOST_PROTOCOL, the EFI_I2C_IO_PROTCOL, or a third party I2C driver interface for a specific device must be used. This requirement is because the I2C host protocol controls the flow of requests to the I2C controller. Use the EFI_I2C_HOST_PROTOCOL when the I2C device is not enumerated by the EFI_I2C_ENUMERATE_PROTOCOL. Use a protocol produced by a third party driver when it is available or the EFI_I2C_IO_PROTOCOL when the third party driver is not available but the device is enumerated with the EFI_I2C_ENUMERATE_PROTOCOL.</p>
<p>When Event is NULL, EnableI2cBusConfiguration operates synchronously and returns the I2C completion status as its return value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>Pointer to an EFI_I2C_BUS_CONFIGURATION_MANAGEMENT_PROTOCOL structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I2cBusConfiguration</td><td>Index of an I2C bus configuration. All values in the range of zero to N-1 are valid where N is the total number of I2C bus configurations for an I2C bus. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Event</td><td>Event to signal when the transaction is complete </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I2cStatus</td><td>Buffer to receive the transaction status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>When Event is NULL, EnableI2cBusConfiguration operates synchrouously and returns the I2C completion status as its return value. In this case it is recommended to use NULL for I2cStatus. The values returned from EnableI2cBusConfiguration are:</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The asynchronous bus configuration request was successfully started when Event is not NULL. </td></tr>
    <tr><td class="paramname">EFI_SUCCESS</td><td>The bus configuration request completed successfully when Event is NULL. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The bus configuration failed. </td></tr>
    <tr><td class="paramname">EFI_NO_MAPPING</td><td>Invalid I2cBusConfiguration value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a8a062f9cd50e63d876c8fd48459ce8e6" name="a8a062f9cd50e63d876c8fd48459ce8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a062f9cd50e63d876c8fd48459ce8e6">&#9670;&#160;</a></span>gEfiI2cBusConfigurationManagementProtocolGuid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="UefiBaseType_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> gEfiI2cBusConfigurationManagementProtocolGuid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reference to variable defined in the .DEC file </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
