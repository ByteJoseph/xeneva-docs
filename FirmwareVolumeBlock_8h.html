<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XenevaOS: XenevaOS/Boot/include/Protocol/FirmwareVolumeBlock.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">XenevaOS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_6f7cbf0a11b44b0a43b1ec16e930d793.html">XenevaOS</a></li><li class="navelem"><a class="el" href="dir_e155a64606be01e9718a8b1197c63fff.html">Boot</a></li><li class="navelem"><a class="el" href="dir_08690fdcb6b3138c931f33749be09044.html">include</a></li><li class="navelem"><a class="el" href="dir_b641ebb3d870e3bbb06aca4db697d2ea.html">Protocol</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">FirmwareVolumeBlock.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a href="FirmwareVolumeBlock_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__EFI__FIRMWARE__VOLUME__BLOCK__PROTOCOL.html">_EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a634425d0868cfc81406f3ab7eb75c63a" id="r_a634425d0868cfc81406f3ab7eb75c63a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="FirmwareVolumeBlock_8h.html#a634425d0868cfc81406f3ab7eb75c63a">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL_GUID</a>&#160;&#160;&#160;  { 0x8f644fa9, 0xe850, 0x4db1, {0x9c, 0xe2, 0xb, 0x44, 0x69, 0x8e, 0x8d, 0xa4 } }</td></tr>
<tr class="separator:a634425d0868cfc81406f3ab7eb75c63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ea3da9db7f3e97b9420ae698511df9" id="r_a63ea3da9db7f3e97b9420ae698511df9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="FirmwareVolumeBlock_8h.html#a63ea3da9db7f3e97b9420ae698511df9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL_GUID</a>&#160;&#160;&#160;  { 0x8f644fa9, 0xe850, 0x4db1, {0x9c, 0xe2, 0xb, 0x44, 0x69, 0x8e, 0x8d, 0xa4 } }</td></tr>
<tr class="separator:a63ea3da9db7f3e97b9420ae698511df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41686b428702e1162e8d16507b2c7048" id="r_a41686b428702e1162e8d16507b2c7048"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="FirmwareVolumeBlock_8h.html#a41686b428702e1162e8d16507b2c7048">EFI_LBA_LIST_TERMINATOR</a>&#160;&#160;&#160;0xFFFFFFFFFFFFFFFFULL</td></tr>
<tr class="separator:a41686b428702e1162e8d16507b2c7048"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad7a8ba0805473947f20ff7ca832b884e" id="r_ad7a8ba0805473947f20ff7ca832b884e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__EFI__FIRMWARE__VOLUME__BLOCK__PROTOCOL.html">_EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="FirmwareVolumeBlock_8h.html#ad7a8ba0805473947f20ff7ca832b884e">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a></td></tr>
<tr class="separator:ad7a8ba0805473947f20ff7ca832b884e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c242031b5d358c39d06cbe0e92b7a9" id="r_ad3c242031b5d358c39d06cbe0e92b7a9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="FirmwareVolumeBlock_8h.html#ad7a8ba0805473947f20ff7ca832b884e">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="FirmwareVolumeBlock_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a></td></tr>
<tr class="separator:ad3c242031b5d358c39d06cbe0e92b7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac2e2422ff9f55e020d85f443137070" id="r_a9ac2e2422ff9f55e020d85f443137070"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="FirmwareVolumeBlock_8h.html#a9ac2e2422ff9f55e020d85f443137070">EFI_FVB_GET_ATTRIBUTES</a>) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="Base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="FirmwareVolumeBlock_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="PiFirmwareVolume_8h.html#a9c9b8f7e8c5c7ea086f40aca0f74fd02">EFI_FVB_ATTRIBUTES_2</a> *Attributes)</td></tr>
<tr class="separator:a9ac2e2422ff9f55e020d85f443137070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa211caf5b28de2482f476166a8ead8d9" id="r_aa211caf5b28de2482f476166a8ead8d9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="FirmwareVolumeBlock_8h.html#aa211caf5b28de2482f476166a8ead8d9">EFI_FVB_SET_ATTRIBUTES</a>) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="Base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="FirmwareVolumeBlock_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="PiFirmwareVolume_8h.html#a9c9b8f7e8c5c7ea086f40aca0f74fd02">EFI_FVB_ATTRIBUTES_2</a> *Attributes)</td></tr>
<tr class="separator:aa211caf5b28de2482f476166a8ead8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825e6b54959a84fdf3bf74e6b5a9a36b" id="r_a825e6b54959a84fdf3bf74e6b5a9a36b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="FirmwareVolumeBlock_8h.html#a825e6b54959a84fdf3bf74e6b5a9a36b">EFI_FVB_GET_PHYSICAL_ADDRESS</a>) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="Base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="FirmwareVolumeBlock_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="UefiBaseType_8h.html#a31bc7e7faeab8d2940ee34f21d41cd04">EFI_PHYSICAL_ADDRESS</a> *<a class="el" href="acpixf_8h.html#a5c9068e87bdb7dd28aaf9b2565a0cc3c">Address</a>)</td></tr>
<tr class="separator:a825e6b54959a84fdf3bf74e6b5a9a36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613ce918657de2427cdf994cfd9b573d" id="r_a613ce918657de2427cdf994cfd9b573d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="FirmwareVolumeBlock_8h.html#a613ce918657de2427cdf994cfd9b573d">EFI_FVB_GET_BLOCK_SIZE</a>) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="Base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="FirmwareVolumeBlock_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="UefiBaseType_8h.html#a3495b0e526b2172f98d5bde00bf28b72">EFI_LBA</a> Lba, <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *BlockSize, <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *NumberOfBlocks)</td></tr>
<tr class="separator:a613ce918657de2427cdf994cfd9b573d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee0dce03ed458232a1a9f06cd0e3b49" id="r_a2ee0dce03ed458232a1a9f06cd0e3b49"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="FirmwareVolumeBlock_8h.html#a2ee0dce03ed458232a1a9f06cd0e3b49">EFI_FVB_READ</a>) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="Base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="FirmwareVolumeBlock_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="UefiBaseType_8h.html#a3495b0e526b2172f98d5bde00bf28b72">EFI_LBA</a> Lba, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> Offset, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *NumBytes, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="actypes_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> *Buffer)</td></tr>
<tr class="separator:a2ee0dce03ed458232a1a9f06cd0e3b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d40ded6464ba907e625c7084ace033e" id="r_a2d40ded6464ba907e625c7084ace033e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="FirmwareVolumeBlock_8h.html#a2d40ded6464ba907e625c7084ace033e">EFI_FVB_WRITE</a>) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="Base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="FirmwareVolumeBlock_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="UefiBaseType_8h.html#a3495b0e526b2172f98d5bde00bf28b72">EFI_LBA</a> Lba, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> Offset, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *NumBytes, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="actypes_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> *Buffer)</td></tr>
<tr class="separator:a2d40ded6464ba907e625c7084ace033e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b299cd35cafc11f30568324373747a" id="r_aa8b299cd35cafc11f30568324373747a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="FirmwareVolumeBlock_8h.html#aa8b299cd35cafc11f30568324373747a">EFI_FVB_ERASE_BLOCKS</a>) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="Base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="FirmwareVolumeBlock_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *This,...)</td></tr>
<tr class="separator:aa8b299cd35cafc11f30568324373747a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac7dd22180e12651e972004706585ac43" id="r_ac7dd22180e12651e972004706585ac43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="UefiBaseType_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="FirmwareVolumeBlock_8h.html#ac7dd22180e12651e972004706585ac43">gEfiFirmwareVolumeBlockProtocolGuid</a></td></tr>
<tr class="separator:ac7dd22180e12651e972004706585ac43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64e73c07c4186a5d85bb74fe2ac0884" id="r_ad64e73c07c4186a5d85bb74fe2ac0884"><td class="memItemLeft" align="right" valign="top"><a class="el" href="UefiBaseType_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="FirmwareVolumeBlock_8h.html#ad64e73c07c4186a5d85bb74fe2ac0884">gEfiFirmwareVolumeBlock2ProtocolGuid</a></td></tr>
<tr class="separator:ad64e73c07c4186a5d85bb74fe2ac0884"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file provides control over block-oriented firmware devices.</p>
<p>Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<br  />
 This program and the accompanying materials are licensed and made available under the terms and conditions of the BSD License that accompanies this distribution. The full text of the license may be found at <a href="http://opensource.org/licenses/bsd-license.php">http://opensource.org/licenses/bsd-license.php</a>.</p>
<p>THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.</p>
<dl class="section user"><dt>Revision Reference: PI</dt><dd>Version 1.0 and 1.2. </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a63ea3da9db7f3e97b9420ae698511df9" name="a63ea3da9db7f3e97b9420ae698511df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ea3da9db7f3e97b9420ae698511df9">&#9670;&#160;</a></span>EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL_GUID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL_GUID&#160;&#160;&#160;  { 0x8f644fa9, 0xe850, 0x4db1, {0x9c, 0xe2, 0xb, 0x44, 0x69, 0x8e, 0x8d, 0xa4 } }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a634425d0868cfc81406f3ab7eb75c63a" name="a634425d0868cfc81406f3ab7eb75c63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634425d0868cfc81406f3ab7eb75c63a">&#9670;&#160;</a></span>EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL_GUID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL_GUID&#160;&#160;&#160;  { 0x8f644fa9, 0xe850, 0x4db1, {0x9c, 0xe2, 0xb, 0x44, 0x69, 0x8e, 0x8d, 0xa4 } }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a41686b428702e1162e8d16507b2c7048" name="a41686b428702e1162e8d16507b2c7048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41686b428702e1162e8d16507b2c7048">&#9670;&#160;</a></span>EFI_LBA_LIST_TERMINATOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_LBA_LIST_TERMINATOR&#160;&#160;&#160;0xFFFFFFFFFFFFFFFFULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>EFI_LBA_LIST_TERMINATOR </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ad3c242031b5d358c39d06cbe0e92b7a9" name="ad3c242031b5d358c39d06cbe0e92b7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c242031b5d358c39d06cbe0e92b7a9">&#9670;&#160;</a></span>EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="FirmwareVolumeBlock_8h.html#ad7a8ba0805473947f20ff7ca832b884e">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a> <a class="el" href="FirmwareVolumeBlock_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7a8ba0805473947f20ff7ca832b884e" name="ad7a8ba0805473947f20ff7ca832b884e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a8ba0805473947f20ff7ca832b884e">&#9670;&#160;</a></span>EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__EFI__FIRMWARE__VOLUME__BLOCK__PROTOCOL.html">_EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a> <a class="el" href="FirmwareVolumeBlock_8h.html#ad7a8ba0805473947f20ff7ca832b884e">EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8b299cd35cafc11f30568324373747a" name="aa8b299cd35cafc11f30568324373747a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b299cd35cafc11f30568324373747a">&#9670;&#160;</a></span>EFI_FVB_ERASE_BLOCKS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_FVB_ERASE_BLOCKS) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="Base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="FirmwareVolumeBlock_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *This,...)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erases and initializes a firmware volume block.</p>
<p>The EraseBlocks() function erases one or more blocks as denoted by the variable argument list. The entire parameter list of blocks must be verified before erasing any blocks. If a block is requested that does not exist within the associated firmware volume (it has a larger index than the last block of the firmware volume), the EraseBlocks() function must return the status code EFI_INVALID_PARAMETER without modifying the contents of the firmware volume. Implementations should be mindful that the firmware volume might be in the WriteDisabled state. If it is in this state, the EraseBlocks() function must return the status code EFI_ACCESS_DENIED without modifying the contents of the firmware volume. All calls to EraseBlocks() must be fully flushed to the hardware before the EraseBlocks() service returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Indicates the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL instance.</td></tr>
    <tr><td class="paramname">...</td><td>The variable argument list is a list of tuples. Each tuple describes a range of LBAs to erase and consists of the following:<ul>
<li>An EFI_LBA that indicates the starting LBA</li>
<li>A UINTN that indicates the number of blocks to erase.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>The list is terminated with an EFI_LBA_LIST_TERMINATOR. For example, the following indicates that two ranges of blocks (5-7 and 10-11) are to be erased: EraseBlocks (This, 5, 3, 10, 2, EFI_LBA_LIST_TERMINATOR);</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The erase request successfully completed.</td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The firmware volume is in the WriteDisabled state. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The block device is not functioning correctly and could not be written. The firmware device may have been partially erased. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>One or more of the LBAs listed in the variable argument list do not exist in the firmware volume. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ac2e2422ff9f55e020d85f443137070" name="a9ac2e2422ff9f55e020d85f443137070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac2e2422ff9f55e020d85f443137070">&#9670;&#160;</a></span>EFI_FVB_GET_ATTRIBUTES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_FVB_GET_ATTRIBUTES) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="Base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="FirmwareVolumeBlock_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="PiFirmwareVolume_8h.html#a9c9b8f7e8c5c7ea086f40aca0f74fd02">EFI_FVB_ATTRIBUTES_2</a> *Attributes)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The GetAttributes() function retrieves the attributes and current settings of the block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Indicates the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL instance.</td></tr>
    <tr><td class="paramname">Attributes</td><td>Pointer to EFI_FVB_ATTRIBUTES_2 in which the attributes and current settings are returned. Type EFI_FVB_ATTRIBUTES_2 is defined in <a class="el" href="structEFI__FIRMWARE__VOLUME__HEADER.html">EFI_FIRMWARE_VOLUME_HEADER</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The firmware volume attributes were returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a613ce918657de2427cdf994cfd9b573d" name="a613ce918657de2427cdf994cfd9b573d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a613ce918657de2427cdf994cfd9b573d">&#9670;&#160;</a></span>EFI_FVB_GET_BLOCK_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_FVB_GET_BLOCK_SIZE) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="Base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="FirmwareVolumeBlock_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="UefiBaseType_8h.html#a3495b0e526b2172f98d5bde00bf28b72">EFI_LBA</a> Lba, <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *BlockSize, <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *NumberOfBlocks)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The GetBlockSize() function retrieves the size of the requested block. It also returns the number of additional blocks with the identical size. The GetBlockSize() function is used to retrieve the block map (see <a class="el" href="structEFI__FIRMWARE__VOLUME__HEADER.html">EFI_FIRMWARE_VOLUME_HEADER</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Indicates the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL instance.</td></tr>
    <tr><td class="paramname">Lba</td><td>Indicates the block for which to return the size.</td></tr>
    <tr><td class="paramname">BlockSize</td><td>Pointer to a caller-allocated UINTN in which the size of the block is returned.</td></tr>
    <tr><td class="paramname">NumberOfBlocks</td><td>Pointer to a caller-allocated UINTN in which the number of consecutive blocks, starting with Lba, is returned. All blocks in this range have a size of BlockSize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The firmware volume base address was returned.</td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The requested LBA is out of range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a825e6b54959a84fdf3bf74e6b5a9a36b" name="a825e6b54959a84fdf3bf74e6b5a9a36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825e6b54959a84fdf3bf74e6b5a9a36b">&#9670;&#160;</a></span>EFI_FVB_GET_PHYSICAL_ADDRESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_FVB_GET_PHYSICAL_ADDRESS) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="Base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="FirmwareVolumeBlock_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="UefiBaseType_8h.html#a31bc7e7faeab8d2940ee34f21d41cd04">EFI_PHYSICAL_ADDRESS</a> *<a class="el" href="acpixf_8h.html#a5c9068e87bdb7dd28aaf9b2565a0cc3c">Address</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The GetPhysicalAddress() function retrieves the base address of a memory-mapped firmware volume. This function should be called only for memory-mapped firmware volumes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Indicates the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL instance.</td></tr>
    <tr><td class="paramname">Address</td><td>Pointer to a caller-allocated EFI_PHYSICAL_ADDRESS that, on successful return from GetPhysicalAddress(), contains the base address of the firmware volume.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The firmware volume base address was returned.</td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The firmware volume is not memory mapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ee0dce03ed458232a1a9f06cd0e3b49" name="a2ee0dce03ed458232a1a9f06cd0e3b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee0dce03ed458232a1a9f06cd0e3b49">&#9670;&#160;</a></span>EFI_FVB_READ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_FVB_READ) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="Base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="FirmwareVolumeBlock_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="UefiBaseType_8h.html#a3495b0e526b2172f98d5bde00bf28b72">EFI_LBA</a> Lba, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> Offset, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *NumBytes, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="actypes_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> *Buffer)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the specified number of bytes into a buffer from the specified block.</p>
<p>The Read() function reads the requested number of bytes from the requested block and stores them in the provided buffer. Implementations should be mindful that the firmware volume might be in the ReadDisabled state. If it is in this state, the Read() function must return the status code EFI_ACCESS_DENIED without modifying the contents of the buffer. The Read() function must also prevent spanning block boundaries. If a read is requested that would span a block boundary, the read must read up to the boundary but not beyond. The output parameter NumBytes must be set to correctly indicate the number of bytes actually read. The caller must be aware that a read may be partially completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Indicates the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL instance.</td></tr>
    <tr><td class="paramname">Lba</td><td>The starting logical block index from which to read.</td></tr>
    <tr><td class="paramname">Offset</td><td>Offset into the block at which to begin reading.</td></tr>
    <tr><td class="paramname">NumBytes</td><td>Pointer to a UINTN. At entry, *NumBytes contains the total size of the buffer. At exit, *NumBytes contains the total number of bytes read.</td></tr>
    <tr><td class="paramname">Buffer</td><td>Pointer to a caller-allocated buffer that will be used to hold the data that is read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The firmware volume was read successfully, and contents are in Buffer.</td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>Read attempted across an LBA boundary. On output, NumBytes contains the total number of bytes returned in Buffer.</td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The firmware volume is in the ReadDisabled state.</td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The block device is not functioning correctly and could not be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa211caf5b28de2482f476166a8ead8d9" name="aa211caf5b28de2482f476166a8ead8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa211caf5b28de2482f476166a8ead8d9">&#9670;&#160;</a></span>EFI_FVB_SET_ATTRIBUTES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_FVB_SET_ATTRIBUTES) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="Base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="FirmwareVolumeBlock_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="PiFirmwareVolume_8h.html#a9c9b8f7e8c5c7ea086f40aca0f74fd02">EFI_FVB_ATTRIBUTES_2</a> *Attributes)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The SetAttributes() function sets configurable firmware volume attributes and returns the new settings of the firmware volume.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Indicates the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL instance.</td></tr>
    <tr><td class="paramname">Attributes</td><td>On input, Attributes is a pointer to EFI_FVB_ATTRIBUTES_2 that contains the desired firmware volume settings. On successful return, it contains the new settings of the firmware volume. Type EFI_FVB_ATTRIBUTES_2 is defined in <a class="el" href="structEFI__FIRMWARE__VOLUME__HEADER.html">EFI_FIRMWARE_VOLUME_HEADER</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The firmware volume attributes were returned.</td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The attributes requested are in conflict with the capabilities as declared in the firmware volume header. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d40ded6464ba907e625c7084ace033e" name="a2d40ded6464ba907e625c7084ace033e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d40ded6464ba907e625c7084ace033e">&#9670;&#160;</a></span>EFI_FVB_WRITE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_FVB_WRITE) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="Base_8h.html#a0c33b494a68ce28497e7ce8e5e95feff">CONST</a> <a class="el" href="FirmwareVolumeBlock_8h.html#ad3c242031b5d358c39d06cbe0e92b7a9">EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="UefiBaseType_8h.html#a3495b0e526b2172f98d5bde00bf28b72">EFI_LBA</a> Lba, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> Offset, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *NumBytes, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="actypes_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> *Buffer)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the specified number of bytes from the input buffer to the block.</p>
<p>The Write() function writes the specified number of bytes from the provided buffer to the specified block and offset. If the firmware volume is sticky write, the caller must ensure that all the bits of the specified range to write are in the EFI_FVB_ERASE_POLARITY state before calling the Write() function, or else the result will be unpredictable. This unpredictability arises because, for a sticky-write firmware volume, a write may negate a bit in the EFI_FVB_ERASE_POLARITY state but cannot flip it back again. Before calling the Write() function, it is recommended for the caller to first call the EraseBlocks() function to erase the specified block to write. A block erase cycle will transition bits from the (NOT)EFI_FVB_ERASE_POLARITY state back to the EFI_FVB_ERASE_POLARITY state. Implementations should be mindful that the firmware volume might be in the WriteDisabled state. If it is in this state, the Write() function must return the status code EFI_ACCESS_DENIED without modifying the contents of the firmware volume. The Write() function must also prevent spanning block boundaries. If a write is requested that spans a block boundary, the write must store up to the boundary but not beyond. The output parameter NumBytes must be set to correctly indicate the number of bytes actually written. The caller must be aware that a write may be partially completed. All writes, partial or otherwise, must be fully flushed to the hardware before the Write() service returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Indicates the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL instance.</td></tr>
    <tr><td class="paramname">Lba</td><td>The starting logical block index to write to.</td></tr>
    <tr><td class="paramname">Offset</td><td>Offset into the block at which to begin writing.</td></tr>
    <tr><td class="paramname">NumBytes</td><td>The pointer to a UINTN. At entry, *NumBytes contains the total size of the buffer. At exit, *NumBytes contains the total number of bytes actually written.</td></tr>
    <tr><td class="paramname">Buffer</td><td>The pointer to a caller-allocated buffer that contains the source for the write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The firmware volume was written successfully.</td></tr>
    <tr><td class="paramname">EFI_BAD_BUFFER_SIZE</td><td>The write was attempted across an LBA boundary. On output, NumBytes contains the total number of bytes actually written.</td></tr>
    <tr><td class="paramname">EFI_ACCESS_DENIED</td><td>The firmware volume is in the WriteDisabled state.</td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The block device is malfunctioning and could not be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad64e73c07c4186a5d85bb74fe2ac0884" name="ad64e73c07c4186a5d85bb74fe2ac0884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64e73c07c4186a5d85bb74fe2ac0884">&#9670;&#160;</a></span>gEfiFirmwareVolumeBlock2ProtocolGuid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="UefiBaseType_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> gEfiFirmwareVolumeBlock2ProtocolGuid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7dd22180e12651e972004706585ac43" name="ac7dd22180e12651e972004706585ac43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7dd22180e12651e972004706585ac43">&#9670;&#160;</a></span>gEfiFirmwareVolumeBlockProtocolGuid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="UefiBaseType_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> gEfiFirmwareVolumeBlockProtocolGuid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
