<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XenevaOS: XenevaOS/Boot/include/Protocol/StorageSecurityCommand.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">XenevaOS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_6f7cbf0a11b44b0a43b1ec16e930d793.html">XenevaOS</a></li><li class="navelem"><a class="el" href="dir_e155a64606be01e9718a8b1197c63fff.html">Boot</a></li><li class="navelem"><a class="el" href="dir_08690fdcb6b3138c931f33749be09044.html">include</a></li><li class="navelem"><a class="el" href="dir_b641ebb3d870e3bbb06aca4db697d2ea.html">Protocol</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">StorageSecurityCommand.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a href="StorageSecurityCommand_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__EFI__STORAGE__SECURITY__COMMAND__PROTOCOL.html">_EFI_STORAGE_SECURITY_COMMAND_PROTOCOL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a052926b1b3fe1c4fcb4b9ed1f3cde3b0" id="r_a052926b1b3fe1c4fcb4b9ed1f3cde3b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="StorageSecurityCommand_8h.html#a052926b1b3fe1c4fcb4b9ed1f3cde3b0">EFI_STORAGE_SECURITY_COMMAND_PROTOCOL_GUID</a></td></tr>
<tr class="separator:a052926b1b3fe1c4fcb4b9ed1f3cde3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:adc5f9b238d6058ae5609296dae9196d5" id="r_adc5f9b238d6058ae5609296dae9196d5"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__EFI__STORAGE__SECURITY__COMMAND__PROTOCOL.html">_EFI_STORAGE_SECURITY_COMMAND_PROTOCOL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="StorageSecurityCommand_8h.html#adc5f9b238d6058ae5609296dae9196d5">EFI_STORAGE_SECURITY_COMMAND_PROTOCOL</a></td></tr>
<tr class="separator:adc5f9b238d6058ae5609296dae9196d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d14b03582b4469f8f9516cca3b9c901" id="r_a3d14b03582b4469f8f9516cca3b9c901"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="StorageSecurityCommand_8h.html#a3d14b03582b4469f8f9516cca3b9c901">EFI_STORAGE_SECURITY_RECEIVE_DATA</a>) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="StorageSecurityCommand_8h.html#adc5f9b238d6058ae5609296dae9196d5">EFI_STORAGE_SECURITY_COMMAND_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> MediaId, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="actypes_8h.html#ab712fece103eee54554694bbc2c1a64e">UINT64</a> Timeout, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="actypes_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> SecurityProtocolId, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="actypes_8h.html#a09f1a1fb2293e33483cc8d44aefb1eb1">UINT16</a> SecurityProtocolSpecificData, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> PayloadBufferSize, <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="acefi_8h.html#a7f319bfc2492a2136964194204e7a8cf">VOID</a> *PayloadBuffer, <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *PayloadTransferSize)</td></tr>
<tr class="separator:a3d14b03582b4469f8f9516cca3b9c901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdee2360b7dfd14827149bbfe5e8e63" id="r_adfdee2360b7dfd14827149bbfe5e8e63"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="StorageSecurityCommand_8h.html#adfdee2360b7dfd14827149bbfe5e8e63">EFI_STORAGE_SECURITY_SEND_DATA</a>) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="StorageSecurityCommand_8h.html#adc5f9b238d6058ae5609296dae9196d5">EFI_STORAGE_SECURITY_COMMAND_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> MediaId, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="actypes_8h.html#ab712fece103eee54554694bbc2c1a64e">UINT64</a> Timeout, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="actypes_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> SecurityProtocolId, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="actypes_8h.html#a09f1a1fb2293e33483cc8d44aefb1eb1">UINT16</a> SecurityProtocolSpecificData, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> PayloadBufferSize, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="acefi_8h.html#a7f319bfc2492a2136964194204e7a8cf">VOID</a> *PayloadBuffer)</td></tr>
<tr class="separator:adfdee2360b7dfd14827149bbfe5e8e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae69c45a37f7d1da6511ee1c86e970b43" id="r_ae69c45a37f7d1da6511ee1c86e970b43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="UefiBaseType_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="StorageSecurityCommand_8h.html#ae69c45a37f7d1da6511ee1c86e970b43">gEfiStorageSecurityCommandProtocolGuid</a></td></tr>
<tr class="separator:ae69c45a37f7d1da6511ee1c86e970b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>EFI Storage Security Command Protocol as defined in UEFI 2.3.1 specification. This protocol is used to abstract mass storage devices to allow code running in the EFI boot services environment to send security protocol commands to mass storage devices without specific knowledge of the type of device or controller that manages the device.</p>
<p>Copyright (c) 2011 - 2018, Intel Corporation. All rights reserved.<br  />
 This program and the accompanying materials are licensed and made available under the terms and conditions of the BSD License which accompanies this distribution. The full text of the license may be found at <a href="http://opensource.org/licenses/bsd-license.php">http://opensource.org/licenses/bsd-license.php</a></p>
<p>THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a052926b1b3fe1c4fcb4b9ed1f3cde3b0" name="a052926b1b3fe1c4fcb4b9ed1f3cde3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a052926b1b3fe1c4fcb4b9ed1f3cde3b0">&#9670;&#160;</a></span>EFI_STORAGE_SECURITY_COMMAND_PROTOCOL_GUID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFI_STORAGE_SECURITY_COMMAND_PROTOCOL_GUID</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  { \</div>
<div class="line">    0xC88B0B6D, 0x0DFC, 0x49A7, {0x9C, 0xB4, 0x49, 0x07, 0x4B, 0x4C, 0x3A, 0x78 } \</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="adc5f9b238d6058ae5609296dae9196d5" name="adc5f9b238d6058ae5609296dae9196d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5f9b238d6058ae5609296dae9196d5">&#9670;&#160;</a></span>EFI_STORAGE_SECURITY_COMMAND_PROTOCOL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__EFI__STORAGE__SECURITY__COMMAND__PROTOCOL.html">_EFI_STORAGE_SECURITY_COMMAND_PROTOCOL</a> <a class="el" href="StorageSecurityCommand_8h.html#adc5f9b238d6058ae5609296dae9196d5">EFI_STORAGE_SECURITY_COMMAND_PROTOCOL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d14b03582b4469f8f9516cca3b9c901" name="a3d14b03582b4469f8f9516cca3b9c901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d14b03582b4469f8f9516cca3b9c901">&#9670;&#160;</a></span>EFI_STORAGE_SECURITY_RECEIVE_DATA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_STORAGE_SECURITY_RECEIVE_DATA) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="StorageSecurityCommand_8h.html#adc5f9b238d6058ae5609296dae9196d5">EFI_STORAGE_SECURITY_COMMAND_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> MediaId, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="actypes_8h.html#ab712fece103eee54554694bbc2c1a64e">UINT64</a> Timeout, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="actypes_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> SecurityProtocolId, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="actypes_8h.html#a09f1a1fb2293e33483cc8d44aefb1eb1">UINT16</a> SecurityProtocolSpecificData, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> PayloadBufferSize, <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="acefi_8h.html#a7f319bfc2492a2136964194204e7a8cf">VOID</a> *PayloadBuffer, <a class="el" href="Base_8h.html#aec78e7a9e90a406a56f859ee456e8eae">OUT</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> *PayloadTransferSize)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a security protocol command to a device that receives data and/or the result of one or more commands sent by SendData.</p>
<p>The ReceiveData function sends a security protocol command to the given MediaId. The security protocol command sent is defined by SecurityProtocolId and contains the security protocol specific data SecurityProtocolSpecificData. The function returns the data from the security protocol command in PayloadBuffer.</p>
<p>For devices supporting the SCSI command set, the security protocol command is sent using the SECURITY PROTOCOL IN command defined in SPC-4.</p>
<p>For devices supporting the ATA command set, the security protocol command is sent using one of the TRUSTED RECEIVE commands defined in ATA8-ACS if PayloadBufferSize is non-zero.</p>
<p>If the PayloadBufferSize is zero, the security protocol command is sent using the Trusted Non-Data command defined in ATA8-ACS.</p>
<p>If PayloadBufferSize is too small to store the available data from the security protocol command, the function shall copy PayloadBufferSize bytes into the PayloadBuffer and return EFI_WARN_BUFFER_TOO_SMALL.</p>
<p>If PayloadBuffer or PayloadTransferSize is NULL and PayloadBufferSize is non-zero, the function shall return EFI_INVALID_PARAMETER.</p>
<p>If the given MediaId does not support security protocol commands, the function shall return EFI_UNSUPPORTED. If there is no media in the device, the function returns EFI_NO_MEDIA. If the MediaId is not the ID for the current media in the device, the function returns EFI_MEDIA_CHANGED.</p>
<p>If the security protocol fails to complete within the Timeout period, the function shall return EFI_TIMEOUT.</p>
<p>If the security protocol command completes without an error, the function shall return EFI_SUCCESS. If the security protocol command completes with an error, the function shall return EFI_DEVICE_ERROR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramname">MediaId</td><td>ID of the medium to receive data from. </td></tr>
    <tr><td class="paramname">Timeout</td><td>The timeout, in 100ns units, to use for the execution of the security protocol command. A Timeout value of 0 means that this function will wait indefinitely for the security protocol command to execute. If Timeout is greater than zero, then this function will return EFI_TIMEOUT if the time required to execute the receive data command is greater than Timeout. </td></tr>
    <tr><td class="paramname">SecurityProtocolId</td><td>The value of the "Security Protocol" parameter of the security protocol command to be sent. </td></tr>
    <tr><td class="paramname">SecurityProtocolSpecificData</td><td>The value of the "Security Protocol Specific" parameter of the security protocol command to be sent. </td></tr>
    <tr><td class="paramname">PayloadBufferSize</td><td>Size in bytes of the payload data buffer. </td></tr>
    <tr><td class="paramname">PayloadBuffer</td><td>A pointer to a destination buffer to store the security protocol command specific payload data for the security protocol command. The caller is responsible for having either implicit or explicit ownership of the buffer. </td></tr>
    <tr><td class="paramname">PayloadTransferSize</td><td>A pointer to a buffer to store the size in bytes of the data written to the payload data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The security protocol command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_WARN_BUFFER_TOO_SMALL</td><td>The PayloadBufferSize was too small to store the available data from the device. The PayloadBuffer contains the truncated data. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The given MediaId does not support security protocol commands. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The security protocol command completed with an error. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no media in the device. </td></tr>
    <tr><td class="paramname">EFI_MEDIA_CHANGED</td><td>The MediaId is not for the current media. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The PayloadBuffer or PayloadTransferSize is NULL and PayloadBufferSize is non-zero. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>A timeout occurred while waiting for the security protocol command to execute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfdee2360b7dfd14827149bbfe5e8e63" name="adfdee2360b7dfd14827149bbfe5e8e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfdee2360b7dfd14827149bbfe5e8e63">&#9670;&#160;</a></span>EFI_STORAGE_SECURITY_SEND_DATA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="UefiBaseType_8h.html#a5f446f35c9f907a4f1cf22e794ba338d">EFI_STATUS</a>(<a class="el" href="AArch64_2ProcessorBind_8h.html#aa3998ed6456694d79e9a45f821f379ed">EFIAPI</a> * EFI_STORAGE_SECURITY_SEND_DATA) (<a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="StorageSecurityCommand_8h.html#adc5f9b238d6058ae5609296dae9196d5">EFI_STORAGE_SECURITY_COMMAND_PROTOCOL</a> *This, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#ae1e6edbbc26d6fbc71a90190d0266018">UINT32</a> MediaId, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="actypes_8h.html#ab712fece103eee54554694bbc2c1a64e">UINT64</a> Timeout, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="actypes_8h.html#ab27e9918b538ce9d8ca692479b375b6a">UINT8</a> SecurityProtocolId, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="actypes_8h.html#a09f1a1fb2293e33483cc8d44aefb1eb1">UINT16</a> SecurityProtocolSpecificData, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="AArch64_2ProcessorBind_8h.html#a4a2fc3b6f740e9cca9f895579c167560">UINTN</a> PayloadBufferSize, <a class="el" href="Base_8h.html#ac2bbd6d630a06a980d9a92ddb9a49928">IN</a> <a class="el" href="acefi_8h.html#a7f319bfc2492a2136964194204e7a8cf">VOID</a> *PayloadBuffer)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a security protocol command to a device.</p>
<p>The SendData function sends a security protocol command containing the payload PayloadBuffer to the given MediaId. The security protocol command sent is defined by SecurityProtocolId and contains the security protocol specific data SecurityProtocolSpecificData. If the underlying protocol command requires a specific padding for the command payload, the SendData function shall add padding bytes to the command payload to satisfy the padding requirements.</p>
<p>For devices supporting the SCSI command set, the security protocol command is sent using the SECURITY PROTOCOL OUT command defined in SPC-4.</p>
<p>For devices supporting the ATA command set, the security protocol command is sent using one of the TRUSTED SEND commands defined in ATA8-ACS if PayloadBufferSize is non-zero. If the PayloadBufferSize is zero, the security protocol command is sent using the Trusted Non-Data command defined in ATA8-ACS.</p>
<p>If PayloadBuffer is NULL and PayloadBufferSize is non-zero, the function shall return EFI_INVALID_PARAMETER.</p>
<p>If the given MediaId does not support security protocol commands, the function shall return EFI_UNSUPPORTED. If there is no media in the device, the function returns EFI_NO_MEDIA. If the MediaId is not the ID for the current media in the device, the function returns EFI_MEDIA_CHANGED.</p>
<p>If the security protocol fails to complete within the Timeout period, the function shall return EFI_TIMEOUT.</p>
<p>If the security protocol command completes without an error, the function shall return EFI_SUCCESS. If the security protocol command completes with an error, the function shall return EFI_DEVICE_ERROR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">This</td><td>Indicates a pointer to the calling context. </td></tr>
    <tr><td class="paramname">MediaId</td><td>ID of the medium to receive data from. </td></tr>
    <tr><td class="paramname">Timeout</td><td>The timeout, in 100ns units, to use for the execution of the security protocol command. A Timeout value of 0 means that this function will wait indefinitely for the security protocol command to execute. If Timeout is greater than zero, then this function will return EFI_TIMEOUT if the time required to execute the receive data command is greater than Timeout. </td></tr>
    <tr><td class="paramname">SecurityProtocolId</td><td>The value of the "Security Protocol" parameter of the security protocol command to be sent. </td></tr>
    <tr><td class="paramname">SecurityProtocolSpecificData</td><td>The value of the "Security Protocol Specific" parameter of the security protocol command to be sent. </td></tr>
    <tr><td class="paramname">PayloadBufferSize</td><td>Size in bytes of the payload data buffer. </td></tr>
    <tr><td class="paramname">PayloadBuffer</td><td>A pointer to a destination buffer to store the security protocol command specific payload data for the security protocol command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EFI_SUCCESS</td><td>The security protocol command completed successfully. </td></tr>
    <tr><td class="paramname">EFI_UNSUPPORTED</td><td>The given MediaId does not support security protocol commands. </td></tr>
    <tr><td class="paramname">EFI_DEVICE_ERROR</td><td>The security protocol command completed with an error. </td></tr>
    <tr><td class="paramname">EFI_NO_MEDIA</td><td>There is no media in the device. </td></tr>
    <tr><td class="paramname">EFI_MEDIA_CHANGED</td><td>The MediaId is not for the current media. </td></tr>
    <tr><td class="paramname">EFI_INVALID_PARAMETER</td><td>The PayloadBuffer is NULL and PayloadBufferSize is non-zero. </td></tr>
    <tr><td class="paramname">EFI_TIMEOUT</td><td>A timeout occurred while waiting for the security protocol command to execute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae69c45a37f7d1da6511ee1c86e970b43" name="ae69c45a37f7d1da6511ee1c86e970b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69c45a37f7d1da6511ee1c86e970b43">&#9670;&#160;</a></span>gEfiStorageSecurityCommandProtocolGuid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="UefiBaseType_8h.html#ad87614428813f71edb2c2d802e9ce2af">EFI_GUID</a> gEfiStorageSecurityCommandProtocolGuid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
